{"body": [{"indent": 0, "text": ["Geometry attributes"], "type": "title", "extent": [0, 24], "level": 0}, {"indent": 0, "type": "summary", "extent": [24, 135], "text": ["Describes how Houdini represents geometry using details, primitives, points, vertices, and attributes."]}, {"body": [{"indent": 0, "type": "para", "extent": [152, 373], "text": [{"text": ["Attributes"], "type": "em"}, " are named values stored on vertices, points, primitives, and objects. Point color, position, ", {"text": ["UV coordinates"], "fullpath": "/shade/textures", "scheme": null, "type": "link", "value": "/shade/textures"}, " , spline weight (", {"text": ["W"], "type": "code"}, "), and normal, for example, are stored as point attributes."]}, {"body": [{"indent": 0, "blevel": 2, "type": "bullet", "extent": [373, 543], "text": ["Houdini sets some point attributes that you can use in expressions. For example, you could set the per-point color based on the vertical position (", {"text": ["PY"], "type": "code"}, ") of the point."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [543, 760], "text": ["Certain attributes you can set manually and if they're present they will be used by Houdini. For example, the dynamics solvers and rendering engines will often use certain attributes on the geometry if they exist."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [760, 875], "text": ["You can also set your own custom attributes to be used by your node expressions, scripts, exporters, and so on."]}], "container": true, "type": "bullet_group"}, {"indent": 0, "type": "para", "extent": [875, 1063], "text": ["The surface nodes in the Attributes group of the tab menu set different types of attributes. You can also set or create arbitrary attributes using the ", {"text": ["Attribute SOP"], "fullpath": "/nodes/sop/attribute", "scheme": "Node", "type": "link", "value": "/nodes/sop/attribute"}, "."]}, {"indent": 0, "type": "para", "extent": [1063, 1264], "text": ["To see the attributes on the geometry in a node, press ", {"keys": ["RMB"], "text": null, "type": "keys"}, " on the node\u2019s tile in the network editor and choose ", {"text": ["Spreadsheet"], "type": "ui"}, " to open the ", {"text": ["geometry spreadsheet"], "fullpath": "/ref/panes/geosheet", "scheme": null, "type": "link", "value": "/ref/panes/geosheet"}, " for the node."]}, {"indent": 0, "type": "para", "extent": [1264, 1689], "text": [{"text": ["Particles"], "fullpath": "/particles", "scheme": null, "type": "link", "value": "/particles"}, "  also have attributes, and attributes are very important when geometry and particle systems interact. For example, particles ", {"text": ["emitted"], "fullpath": "/particles/emit", "scheme": null, "type": "link", "value": "/particles/emit"}, " from geometry inherit (by default) the attributes of the point from which they are emitted, and you can create interesting effects by transferring attributes between surfaces and particles using the ", {"text": ["Attribute Transfer POP"], "fullpath": "/nodes/pop/attribtransfer", "scheme": "Node", "type": "link", "value": "/nodes/pop/attribtransfer"}, "."]}], "indent": 0, "level": 2, "text": ["Attributes"], "extent": [135, 152], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "extent": [1751, 2095], "text": ["You can create/set attributes using the generic ", {"text": ["Attribute Create"], "fullpath": "/nodes/sop/attribcreate", "scheme": "Node", "type": "link", "value": "/nodes/sop/attribcreate"}, " surface node, or the ", {"text": ["Vertex"], "fullpath": "/nodes/sop/vertex", "scheme": "Node", "type": "link", "value": "/nodes/sop/vertex"}, ", ", {"text": ["Point"], "fullpath": "/nodes/sop/point", "scheme": "Node", "type": "link", "value": "/nodes/sop/point"}, ", ", {"text": ["Primitive"], "fullpath": "/nodes/sop/primitive", "scheme": "Node", "type": "link", "value": "/nodes/sop/primitive"}, " nodes. You can attach attributes to vertices, points, primitives (e.g. polygon faces), or the entire piece of geometry (called the \"detail\" level)."]}, {"body": [{"body": [{"indent": 8, "type": "para", "extent": [2105, 2351], "text": ["When you merge two or more branches in a geometry network, if a detail attribute with the same name exists in multiple branches, Houdini uses the value in the first branch. If the attribute is a string array, Houdini merges the arrays."]}], "indent": 4, "role": "item", "extent": [2095, 2105], "container": true, "type": "note"}], "container": true, "role": "item_group", "type": "note_group"}], "indent": 0, "text": [{"text": "", "fullpath": "/model/images/geo_detail.png", "scheme": "Image", "type": "link", "value": "images/geo_detail.png"}], "role": "item", "extent": [1715, 1751], "container": true, "type": "fig"}], "container": true, "role": "item_group", "type": "fig_group"}], "indent": 0, "level": 2, "text": ["Geometry components"], "extent": [1689, 1715], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [2378, 2519], "text": ["When two components in the same geometry have an attribute with the same name, the attribute on the \"lower level\" of geometry is used, so:"]}, {"body": [{"body": [{"body": [{"body": [{"body": [{"body": [{"body": [{"indent": 12, "blevel": 14, "type": "bullet", "extent": [2653, 2706], "text": [{"text": ["Detail"], "type": "strong"}, " (whole geometry) attributes"]}], "container": true, "type": "bullet_group"}], "indent": 8, "text": [{"text": ["Primitive"], "type": "strong"}, " attributes, which override:"], "extent": [2602, 2653], "container": true, "blevel": 10, "type": "bullet"}], "container": true, "type": "bullet_group"}], "indent": 4, "text": [{"text": ["Point"], "type": "strong"}, " attributes, which override:"], "extent": [2559, 2602], "container": true, "blevel": 6, "type": "bullet"}], "container": true, "type": "bullet_group"}], "indent": 0, "text": [{"text": ["Vertex"], "type": "strong"}, " attributes, which override:"], "extent": [2519, 2559], "container": true, "blevel": 2, "type": "bullet"}], "container": true, "type": "bullet_group"}], "indent": 0, "level": 2, "text": ["Attribute precedence"], "extent": [2351, 2378], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [2753, 3132], "text": ["Most surface nodes have a ", {"text": ["Group"], "type": "ui"}, " field that lets you enter a named group or a pattern to select which components the node should apply to. This field recognizes special syntax that lets you select components by the value of an attribute. For example, in a ", {"text": ["Point node"], "fullpath": "/nodes/sop/point", "scheme": "Node", "type": "link", "value": "/nodes/sop/point"}, "'s ", {"text": ["Group"], "type": "ui"}, " field, ", {"text": ["@foo>5"], "type": "code"}, " selects all points whose ", {"text": ["foo"], "type": "code"}, " attribute is greater than ", {"text": ["5"], "type": "code"}, "."]}, {"indent": 0, "type": "para", "extent": [3132, 3218], "text": ["See the section on ", {"fragment": "#manual", "text": ["manually specifying groups"], "value": "groups#manual", "fullpath": "/model/groups#manual", "scheme": null, "type": "link"}, " for more information."]}], "indent": 0, "level": 2, "text": ["Applying nodes based on attribute values"], "extent": [2706, 2753], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [3253, 3455], "text": ["Since Houdini 18.5, SOP geometry supports dictionary attributes, an attribute type where each element (point, vertex, primitive/face, or the whole geometry/detail) can store a set of key/value pairs."]}, {"body": [{"indent": 0, "blevel": 2, "type": "bullet", "extent": [3455, 3638], "text": ["You could use a dictionary attribute to store complex \"blind\" element data, such as game engine data, or data for a foreign geometry format that Houdini does not support natively."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [3638, 3722], "text": ["You could store metadata about geometry in a dictionary attribute on the detail."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [3722, 4022], "text": ["You could store the parameter values of the node that created different elements, for debugging. You could even store a node network as geometry by representing nodes with points and wires and parameters in a dictionary point attribute. See the ", {"text": ["Attribute From Parms SOP"], "fullpath": "/nodes/sop/attribfromparm", "scheme": "Node", "type": "link", "value": "/nodes/sop/attribfromparm"}, "."]}], "container": true, "type": "bullet_group"}, {"indent": 0, "type": "para", "extent": [4022, 4167], "text": ["(You can also create a ", {"text": ["dictionary array"], "type": "em"}, " attribute, where the attribute value is an ", {"text": ["array"], "type": "em"}, " of dictionaries, rather than a single dictionary.)"]}, {"indent": 0, "type": "para", "extent": [4167, 4465], "text": ["Dictionary keys are strings. Dictionary values can be string, number, an array, or a (nested) dictionary. ", {"text": ["Dictionary attributes essentially have the same data model as JSON"], "type": "strong"}, ". In fact, UI such as the geometry spreadsheet displays the contents of a dictionary attribute like a JSON-encoded string."]}, {"indent": 0, "type": "para", "extent": [4465, 4783], "text": ["Currently, support for dictionary attributes is mostly in Python, VEX, VOPs. You can manipulate dictionary attributes on geometry using VEX snippets in an ", {"text": ["Attribute Wrangle"], "fullpath": "/nodes/sop/attribwrangle", "scheme": "Node", "type": "link", "value": "/nodes/sop/attribwrangle"}, ", or with a ", {"text": ["Python SOP"], "fullpath": "/nodes/sop/python", "scheme": "Node", "type": "link", "value": "/nodes/sop/python"}, ". There is also simple support for reading key values in parameter expressions."]}, {"body": [{"body": [{"indent": 0, "text": ["VEX/VOPs "], "role": "td", "extent": [4810, 4822], "container": true, "type": "cell"}, {"body": [{"body": [{"indent": 4, "blevel": 6, "type": "bullet", "extent": [4822, 4971], "text": ["Use the ", {"text": ["standard VEX functions for reading attribute values"], "fullpath": "/vex/attrib_suite", "scheme": null, "type": "link", "value": "/vex/attrib_suite"}, " to get the entire dictionary as a VEX ", {"text": ["dict type"], "fullpath": "/vex/dicts", "scheme": null, "type": "link", "value": "/vex/dicts"}, "."]}, {"indent": 4, "blevel": 6, "type": "bullet", "extent": [4971, 5089], "text": ["You can check for the existence of a key with ", {"text": "", "value": "/vex/functions/hasdetailattrib", "fallback_text": "hasdetailattrib()", "fullpath": "/vex/functions/hasdetailattrib", "scheme": "Vex", "type": "link"}, " using ", {"text": [{"text": ["attr_name"], "type": "var"}, ".", {"text": ["key"], "type": "var"}], "type": "code"}, " as the name."]}, {"indent": 4, "blevel": 6, "type": "bullet", "extent": [5089, 5216], "text": ["You can bind with a dictionary attribute in a VEX snippet with ", {"text": ["d@foo"], "type": "code"}, " (or ", {"text": ["d[]@foo"], "type": "code"}, " for a dictionary array attribute)."]}, {"indent": 4, "blevel": 6, "type": "bullet", "extent": [5216, 5471], "text": ["You can use ", {"text": ["[]"], "type": "code"}, " to index, however VEX has return type inference so you may need return casts to do this. (The dictionary entry is any-type, but must be resolved at compile time to a specific type.) Referring to a missing key returns a zero-value."]}, {"indent": 4, "blevel": 6, "type": "bullet", "extent": [5471, 5759], "text": ["VEX/VOPs has functions for manipulating dictionaries, and several functions for working with arrays also work with ", {"text": ["dict"], "type": "code"}, " objects. For example, ", {"text": "", "value": "/vex/functions/len", "fallback_text": "len()", "fullpath": "/vex/functions/len", "scheme": "Vex", "type": "link"}, " on a ", {"text": ["dict"], "type": "code"}, " returns the number of items in the dictionary, and ", {"text": "", "value": "/vex/functions/isvalidindex", "fallback_text": "isvalidindex()", "fullpath": "/vex/functions/isvalidindex", "scheme": "Vex", "type": "link"}, " tells if a key is present in the dictionary."]}, {"indent": 4, "blevel": 6, "type": "bullet", "extent": [5759, 5937], "text": ["The ", {"text": "", "value": "/vex/functions/keys", "fallback_text": "keys()", "fullpath": "/vex/functions/keys", "scheme": "Vex", "type": "link"}, " returns the dictionary keys as an array of strings. (It is not possible to have an equivalent function for values since arrays must be single type in VEX)."]}, {"body": [{"indent": 8, "type": "para", "extent": [6040, 6104], "text": [{"text": ["dict foo = set( 'key1', 3.2, 'key2', 'stringvalue');"], "type": "code"}]}], "indent": 4, "text": ["The ", {"text": "", "value": "/vex/functions/set", "fallback_text": "set()", "fullpath": "/vex/functions/set", "scheme": "Vex", "type": "link"}, " function lets you build up a dictionary from alternating key and value arguments:"], "extent": [5937, 6040], "container": true, "blevel": 6, "type": "bullet"}], "container": true, "type": "bullet_group"}, {"indent": 4, "type": "para", "extent": [6104, 6224], "text": ["See the documentation for the ", {"text": ["VEX dict type"], "fullpath": "/vex/dicts", "scheme": null, "type": "link", "value": "/vex/dicts"}, " for more information on working with ", {"text": ["dict"], "type": "code"}, " types in VEX."]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 0, "text": ["Python "], "role": "td", "extent": [6224, 6233], "container": true, "type": "cell"}, {"body": [{"body": [{"indent": 4, "blevel": 6, "type": "bullet", "extent": [6233, 6507], "text": ["Use the standard ", {"text": "", "value": "/hom/hou/Geometry", "fallback_text": "hou.Geometry", "fullpath": "/hom/hou/Geometry", "scheme": "Hom", "type": "link"}, " methods (for example, ", {"fragment": "#attribValue", "text": "", "value": "/hom/hou/Geometry#attribValue", "fallback_text": "hou.Geometry.attribValue", "fullpath": "/hom/hou/Geometry#attribValue", "scheme": "Hom", "type": "link"}, " for detail attributes) to read a dictionary attribute. This will return the entire dictionary as a Python ", {"text": ["dict"], "type": "code"}, " containing Python types (", {"text": ["int"], "type": "code"}, ", ", {"text": ["float"], "type": "code"}, ", ", {"text": ["str"], "type": "code"}, ", ", {"text": ["list"], "type": "code"}, ", ", {"text": ["dict"], "type": "code"}, ")."]}, {"indent": 4, "blevel": 6, "type": "bullet", "extent": [6507, 6795], "text": ["Since the attribute methods return a pure Python structure, once you read the attribute value you can use regular Python to manipulate the data. For example, ", {"text": ["len()"], "type": "code"}, " to get the number of items in the dictionary, ", {"text": ["dict[\"", {"text": ["key"], "type": "var"}, "\"]"], "type": "code"}, " to get the value associated with a key, and so on."]}], "container": true, "type": "bullet_group"}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 0, "text": ["Expressions "], "role": "td", "extent": [6795, 6809], "container": true, "type": "cell"}, {"body": [{"body": [{"indent": 4, "blevel": 6, "type": "bullet", "extent": [6809, 7027], "text": ["You can read the value of a dictionary key in an expression with the standard functions reading attribute values (", {"text": "", "value": "/expressions/detail", "fallback_text": "detail()", "fullpath": "/expressions/detail", "scheme": "Exp", "type": "link"}, ", ", {"text": "", "value": "/expressions/point", "fallback_text": "point()", "fullpath": "/expressions/point", "scheme": "Exp", "type": "link"}, ", ", {"text": "", "value": "/expressions/vertex", "fallback_text": "vertex()", "fullpath": "/expressions/vertex", "scheme": "Exp", "type": "link"}, ", ", {"text": "", "value": "/expressions/prim", "fallback_text": "prim()", "fullpath": "/expressions/prim", "scheme": "Exp", "type": "link"}, "), using ", {"text": [{"text": ["attr_name"], "type": "var"}, ".", {"text": ["key"], "type": "var"}], "type": "code"}, " as the name."]}, {"indent": 4, "blevel": 6, "type": "bullet", "extent": [7027, 7352], "text": ["If you use the string attribute functions (", {"text": "", "value": "/expressions/details", "fallback_text": "details()", "fullpath": "/expressions/details", "scheme": "Exp", "type": "link"}, ", ", {"text": "", "value": "/expressions/points", "fallback_text": "points()", "fullpath": "/expressions/points", "scheme": "Exp", "type": "link"}, ", ", {"text": "", "value": "/expressions/vertexs", "fallback_text": "vertexs()", "fullpath": "/expressions/vertexs", "scheme": "Exp", "type": "link"}, ", ", {"text": "", "value": "/expressions/prims", "fallback_text": "prims()", "fullpath": "/expressions/prims", "scheme": "Exp", "type": "link"}, ") to read the whole attribute value, it will return a JSON-encoded string. However, there are no JSON-parsing expression functions, and limited string manipulation functions, to deal with such a string in an expression."]}], "container": true, "type": "bullet_group"}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}], "type": "table", "thead": [{"body": [{"indent": 0, "text": ["Language "], "role": "th", "extent": [4783, 4795], "container": true, "type": "cell"}, {"indent": 4, "role": "th", "type": "cell", "extent": [4795, 4810], "text": ["Support "]}], "divider": false, "type": "row"}]}, {"body": [{"body": [{"indent": 4, "type": "para", "extent": [7357, 7622], "text": ["The ", {"text": ["Attribute Create node"], "fullpath": "/nodes/sop/attribcreate", "scheme": "Node", "type": "link", "value": "/nodes/sop/attribcreate"}, " only creates an empty dictionary attribute. The best way currently to actually set dictionary values in a geometry network is with a ", {"text": ["Python SOP"], "fullpath": "/nodes/sop/python", "scheme": "Node", "type": "link", "value": "/nodes/sop/python"}, " or ", {"text": ["Attribute Wrangle"], "fullpath": "/nodes/sop/attribwrangle", "scheme": "Node", "type": "link", "value": "/nodes/sop/attribwrangle"}, "."]}], "indent": 0, "role": "item", "extent": [7352, 7357], "container": true, "type": "tip"}], "container": true, "role": "item_group", "type": "tip_group"}], "indent": 0, "level": 2, "text": ["Dictionary attributes"], "extent": [3218, 3253], "container": true, "type": "h", "id": "dict"}, {"body": [{"indent": 0, "type": "para", "extent": [7661, 7795], "text": [{"text": ["Intrinsic attributes"], "type": "em"}, " are ", {"text": ["computed values"], "type": "em"}, " derived from the geometry that you can access as if they were attributes. For example:"]}, {"body": [{"body": [{"body": [{"body": [{"indent": 4, "text": ["Detail "], "role": "td", "extent": [7834, 7847], "container": true, "type": "cell"}, {"indent": 8, "text": [{"text": ["intrinsic:pointcount"], "type": "code"}, " "], "role": "td", "extent": [7847, 7880], "container": true, "type": "cell"}, {"body": [{"indent": 12, "type": "para", "extent": [7880, 7926], "text": ["Number of points in the geometry"]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 4, "text": ["Detail/primitive "], "role": "td", "extent": [7926, 7949], "container": true, "type": "cell"}, {"indent": 8, "text": [{"text": ["intrinsic:bounds"], "type": "code"}, " "], "role": "td", "extent": [7949, 7978], "container": true, "type": "cell"}, {"body": [{"indent": 12, "type": "para", "extent": [7978, 8020], "text": ["Bounding box of the geometry"]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 4, "text": ["Primitive "], "role": "td", "extent": [8020, 8036], "container": true, "type": "cell"}, {"indent": 8, "text": [{"text": ["intrinsic:measuredarea"], "type": "code"}, " "], "role": "td", "extent": [8036, 8071], "container": true, "type": "cell"}, {"body": [{"indent": 12, "type": "para", "extent": [8071, 8114], "text": ["Surface area of the geometry."]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 4, "text": ["Primitive "], "role": "td", "extent": [8114, 8130], "container": true, "type": "cell"}, {"indent": 8, "text": [{"text": ["intrinsic:memoryusage"], "type": "code"}, " "], "role": "td", "extent": [8130, 8164], "container": true, "type": "cell"}, {"body": [{"indent": 12, "type": "para", "extent": [8164, 8217], "text": ["Amount of memory used by the primitive."]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}], "type": "table", "thead": []}], "indent": 0, "text": [" Examples of intrinsic attributes"], "role": "item", "extent": [7795, 7834], "container": true, "type": "box"}], "container": true, "role": "item_group", "type": "box_group"}, {"body": [{"body": [{"body": [{"indent": 4, "blevel": 6, "type": "bullet", "extent": [8270, 8366], "text": ["The command line utility ", {"text": ["ginfo -I"], "type": "code"}, " prints a list of all known intrinsic attributes."]}, {"body": [{"indent": 8, "type": "para", "extent": [8489, 8696], "text": ["If you are viewing geometry at a component level that has intrinsic attributes, you can use the ", {"text": ["Intrinsics"], "type": "ui"}, " menu to show all intrinsics or choose which intrinsics to show in the spreadsheet."]}], "indent": 4, "text": ["You can show intrinsic attributes in the ", {"text": ["geometry spreadsheet"], "fullpath": "/ref/panes/geosheet", "scheme": null, "type": "link", "value": "/ref/panes/geosheet"}, ". By default they are not shown."], "extent": [8366, 8489], "container": true, "blevel": 6, "type": "bullet"}, {"indent": 4, "blevel": 6, "type": "bullet", "extent": [8696, 8822], "text": ["The ", {"text": ["Inspect tool"], "fullpath": "/basics/inspection", "scheme": null, "type": "link", "value": "/basics/inspection"}, " can show which intrinsic attributes are available on the inspected geometry."]}], "container": true, "type": "bullet_group"}], "indent": 0, "text": [" See what intrinsic attributes are available"], "role": "item", "extent": [8217, 8270], "container": true, "type": "task"}, {"body": [{"body": [{"body": [{"lang": "expr", "indent": 8, "type": "pre", "extent": [8965, 9057], "text": ["\n        prim(\"../volume1\", 0, \"intrinsic:bounds\", 0)\n        "]}, {"indent": 8, "type": "para", "extent": [9057, 9306], "text": ["(You can\u2019t use the ", {"text": ["@"], "type": "code"}, " attribute shortcut to read an intrinsic in VEX wrangle snippets. However, you can use ", {"text": "", "value": "/vex/functions/primintrinsic", "fallback_text": "primintrinsic()", "fullpath": "/vex/functions/primintrinsic", "scheme": "Vex", "type": "link"}, " and ", {"text": "", "value": "/vex/functions/detailintrinsic", "fallback_text": "detailintrinsic()", "fullpath": "/vex/functions/detailintrinsic", "scheme": "Vex", "type": "link"}, " to read the intrinsic directly instead of using the ", {"text": ["intrinsic:"], "type": "code"}, " prefix magic.)"]}], "indent": 4, "text": ["In HScript expressions and VEX, use the attribute functions to read intrinsic attributes, for example:"], "extent": [8855, 8965], "container": true, "blevel": 6, "type": "bullet"}, {"indent": 4, "blevel": 6, "type": "bullet", "extent": [9306, 9519], "text": ["In Python, you can access intrinsic attributes using ", {"fragment": "#intrinsicNames", "text": "", "value": "/hom/hou/Geometry#intrinsicNames", "fallback_text": "hou.Geometry.intrinsicNames", "fullpath": "/hom/hou/Geometry#intrinsicNames", "scheme": "Hom", "type": "link"}, ", ", {"fragment": "#intrinsicValue", "text": [".intrinsicValue()"], "value": "/hom/hou/Geometry#intrinsicValue", "fullpath": "/hom/hou/Geometry#intrinsicValue", "scheme": "Hom", "type": "link"}, ", and ", {"fragment": "#intrinsicValueDict", "text": [".intrinsicValueDict()"], "value": "/hom/hou/Geometry#intrinsicValueDict", "fullpath": "/hom/hou/Geometry#intrinsicValueDict", "scheme": "Hom", "type": "link"}, "."]}, {"indent": 4, "blevel": 6, "type": "bullet", "extent": [9519, 9645], "text": ["In the ", {"fragment": "#manual", "text": ["group syntax"], "value": "groups#manual", "fullpath": "/model/groups#manual", "scheme": null, "type": "link"}, ", you can group based on intrinsic values. For example, ", {"text": ["@intrinsic:indexorder<100"], "type": "code"}]}], "container": true, "type": "bullet_group"}], "indent": 0, "text": [" Use intrinsic attributes"], "role": "item", "extent": [8822, 8855], "container": true, "type": "task"}], "container": true, "role": "item_group", "type": "task_group"}, {"body": [{"body": [{"indent": 4, "type": "para", "extent": [9650, 9892], "text": ["Despite the name, some \"intrinsic\" attributes can actually be written to, causing Houdini or Mantra to change some internal setting. For example, you can set the ", {"text": ["intrinsic:unexpandedfilename"], "type": "code"}, " intrinsic attribute on a packed primitive."]}], "indent": 0, "role": "item", "extent": [9645, 9650], "container": true, "type": "tip"}], "container": true, "role": "item_group", "type": "tip_group"}], "indent": 0, "level": 2, "text": ["Intrinsic attributes"], "extent": [7622, 7661], "container": true, "type": "h", "id": "intrinsic"}, {"body": [{"indent": 0, "type": "para", "extent": [9933, 10234], "text": ["You can choose the numeric precision of attributes you create with the ", {"text": ["Attribute Create node"], "fullpath": "/nodes/sop/attribcreate", "scheme": "Node", "type": "link", "value": "/nodes/sop/attribcreate"}, ", and/or convert attributes to higher precision types (at the cost of more memory) or lower precision types (to save memory) using the ", {"text": ["Attrib Cast surface node"], "fullpath": "/nodes/sop/attribcast", "scheme": "Node", "type": "link", "value": "/nodes/sop/attribcast"}, "."]}, {"indent": 0, "type": "para", "extent": [10234, 10351], "text": ["See ", {"text": ["the help for Attrib Cast"], "fullpath": "/nodes/sop/attribcast", "scheme": "Node", "type": "link", "value": "/nodes/sop/attribcast"}, " for information on the available storage types and limitations."]}], "indent": 0, "level": 2, "text": ["Higher and lower precision storage"], "extent": [9892, 9933], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [10386, 10716], "text": ["You may see the following \"pseudo-attributes\" in ", {"text": ["VEX snippets"], "fullpath": "/vex/snippets", "scheme": null, "type": "link", "value": "/vex/snippets"}, ". They represent the number of the current element being processed (for example, the point number), and the total number of elements in the geometry/list. See ", {"fragment": "#indexing", "text": ["indexing and limit variables in VEX snippets"], "value": "/vex/snippets#indexing", "fullpath": "/vex/snippets#indexing", "scheme": null, "type": "link"}, " for more information."]}, {"body": [{"body": [{"indent": 4, "type": "para", "extent": [10761, 10837], "text": ["Represent the number of the current element when a VEX snippet is run."]}], "indent": 0, "text": [{"text": ["@elemnum"], "type": "code"}, ", ", {"text": ["@ptnum"], "type": "code"}, ", ", {"text": ["@primnum"], "type": "code"}, ", ", {"text": ["@vtxnum"], "type": "code"}], "extent": [10716, 10761], "container": true, "type": "dt"}, {"body": [{"indent": 4, "type": "para", "extent": [10882, 10975], "text": ["Represent the total number of elements in the geometry/list when a VEX snipped is run."]}], "indent": 0, "text": [{"text": ["@numelem"], "type": "code"}, ", ", {"text": ["@numpt"], "type": "code"}, ", ", {"text": ["@numprim"], "type": "code"}, ", ", {"text": ["@numvtx"], "type": "code"}], "extent": [10837, 10882], "container": true, "type": "dt"}], "container": true, "type": "dt_group"}], "indent": 0, "level": 2, "text": ["Indexing and limit variables"], "extent": [10351, 10386], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [11005, 11247], "text": ["Each type of node will use certain attributes if they exist (or in some cases require them to exist), and may create/set attributes as part of their operation. See the documentation for individual nodes to see what attributes they use/set."]}, {"indent": 0, "type": "para", "extent": [11247, 11352], "text": ["The following lists a number of attributes that by convention are read/written by multiple node types."]}, {"indent": 0, "text": [" Geometry attributes "], "type": "sep", "extent": [11352, 11382], "level": 4}, {"body": [{"body": [{"indent": 4, "type": "para", "extent": [11426, 11570], "text": ["Point position. The viewport uses this to lay out the points of the model in 3D space. You can overwrite this attribute to move the point."]}], "indent": 0, "text": [{"text": ["P"], "type": "code"}], "role": "item", "attrs": {"on": "point", "type": "vector"}, "extent": [11382, 11388], "container": true, "type": "attributes_item", "id": "p"}, {"body": [{"indent": 4, "type": "para", "extent": [11598, 11676], "text": ["Normal direction. You can overwrite this attribute to change the normal."]}], "indent": 0, "text": [{"text": ["N"], "type": "code"}], "role": "item", "attrs": {"type": "vector"}, "extent": [11570, 11575], "container": true, "type": "attributes_item", "id": "n"}, {"body": [{"indent": 4, "type": "para", "extent": [11704, 11962], "text": ["Velocity. The renderer uses this attribute to know where to add motion blur. This attribute is not computed automatically, but several nodes, especially particle DOPs, can set/use it. You can add velocity to points using the ", {"text": ["Trail SOP"], "fullpath": "/nodes/sop/trail", "scheme": "Node", "type": "link", "value": "/nodes/sop/trail"}, "."]}], "indent": 0, "text": [{"text": ["v"], "type": "code"}], "role": "item", "attrs": {"type": "vector"}, "extent": [11676, 11681], "container": true, "type": "attributes_item", "id": "v"}, {"body": [{"indent": 4, "type": "para", "extent": [11988, 12301], "text": ["A unique element ID. This is not the same as the element number (for example, the point number). This is an attribute you can, for example, assign to points to keep track of them even if the point numbers change (which can happen if the number of points changes). Particle DOPs often set/use this attribute."]}], "indent": 0, "text": [{"text": ["id"], "type": "code"}], "role": "item", "attrs": {"type": "int"}, "extent": [11962, 11968], "container": true, "type": "attributes_item", "id": "id"}, {"body": [{"indent": 4, "type": "para", "extent": [12332, 12499], "text": ["This is a value you can set on primitives, such as volumes or packed primitives, to be able to find them in code by name. Some nodes set/read this attribute."]}], "indent": 0, "text": [{"text": ["name"], "type": "code"}], "role": "item", "attrs": {"type": "string"}, "extent": [12301, 12309], "container": true, "type": "attributes_item", "id": "name"}, {"body": [{"indent": 4, "type": "para", "extent": [12528, 12805], "text": ["Nodes the break up geometry into pieces will often set this attribute so you can tell which polygonal faces are part of the same piece. Faces in the same piece will share the same value in their ", {"text": ["piece"], "type": "code"}, " attribute. Other nodes may use this attribute to operate on pieces."]}], "indent": 0, "text": [{"text": ["piece"], "type": "code"}], "role": "item", "attrs": {"type": "int"}, "extent": [12499, 12508], "container": true, "type": "attributes_item", "id": "piece"}], "container": true, "role": "item_group", "type": "attributes_item_group"}, {"indent": 0, "text": [" Sizes and rotations "], "type": "sep", "extent": [12805, 12835], "level": 4}, {"body": [{"body": [{"indent": 4, "type": "para", "extent": [12868, 13135], "text": ["Uniform scaling factor. This is used in different ways in different places. For particle/point rendering, it controls the size of the particle/point (in world space units) at render time. For instancing, you can use it to uniformly scale the instanced geometry."]}], "indent": 0, "text": [{"text": ["pscale"], "type": "code"}], "role": "item", "attrs": {"type": "float"}, "extent": [12835, 12846], "container": true, "type": "attributes_item", "id": "pscale"}, {"body": [{"indent": 4, "type": "para", "extent": [13167, 13366], "text": ["Whereas ", {"text": ["pscale"], "type": "code"}, " is a single uniform scaling factor in all axes, this attribute lets you scale non-uniformly along each axis separately. See ", {"fragment": "#pscale", "text": ["the pscale attribute"], "value": "#pscale", "fullpath": "/model/attributes#pscale", "scheme": null, "type": "link"}, " for more information."]}], "indent": 0, "text": [{"text": ["scale"], "type": "code"}], "role": "item", "attrs": {"type": "vector"}, "extent": [13135, 13144], "container": true, "type": "attributes_item", "id": "scale"}, {"body": [{"indent": 4, "type": "para", "extent": [13412, 13619], "text": ["When rendering open curves, sets the line width (in world space units) at render time. If this attribute does not exist, Mantra renders the open curve a thin line instead of as a ribbon with thickness."]}], "indent": 0, "text": [{"text": ["width"], "type": "code"}], "role": "item", "attrs": {"on": "point", "type": "float"}, "extent": [13366, 13375], "container": true, "type": "attributes_item", "id": "width"}, {"body": [{"indent": 4, "type": "para", "extent": [13670, 13724], "text": ["Level of detail. This may be used in instancing."]}], "indent": 0, "text": [{"text": ["lod"], "type": "code"}], "role": "item", "attrs": {"on": "detail, prim", "type": "float"}, "extent": [13619, 13626], "container": true, "type": "attributes_item", "id": "lod"}, {"body": [{"indent": 4, "type": "para", "extent": [13801, 13905], "text": ["When displaying particles using sprint images, this gives additional sprite scaling over ", {"text": ["pscale"], "type": "code"}, "."]}], "indent": 0, "text": [{"text": ["spritescale"], "type": "code"}], "role": "item", "attrs": {"default": "(1, 1, 1)", "on": "point", "type": "vector"}, "extent": [13724, 13739], "container": true, "type": "attributes_item", "id": "spritescale"}, {"body": [{"indent": 4, "type": "para", "extent": [13971, 14085], "text": ["When displaying particles using sprint images, this gives sprite rotation (around camera angle) in degrees."]}], "indent": 0, "text": [{"text": ["spriterot"], "type": "code"}], "role": "item", "attrs": {"default": "0", "on": "point", "type": "float"}, "extent": [13905, 13918], "container": true, "type": "attributes_item", "id": "spriterot"}], "container": true, "role": "item_group", "type": "attributes_item_group"}, {"indent": 0, "text": [" Viewport display attributes "], "type": "sep", "extent": [14085, 14123], "level": 4}, {"body": [{"body": [{"indent": 4, "type": "para", "extent": [14192, 14286], "text": ["If this detail attribute is 1, the geometry always appears as wireframe in the viewport."]}, {"indent": 4, "type": "para", "extent": [14286, 14543], "text": ["If this detail attribute is -1, the geometry always appears as shaded in\n    the viewport. For guide geometry, which are normally only drawn as\n    wireframe, this allows them to also be drawn as shaded when using any of\n    the shaded viewport modes."]}], "indent": 0, "text": [{"text": ["gl_wireframe"], "type": "code"}], "role": "item", "attrs": {"default": "0", "on": "detail", "type": "int"}, "extent": [14123, 14140], "container": true, "type": "attributes_item", "id": "gl_wireframe"}, {"body": [{"indent": 4, "type": "para", "extent": [14605, 14737], "text": ["If this detail attribute is not 0, the geometry always appears without lighting. This is currently ignored for guide geometry."]}], "indent": 0, "text": [{"text": ["gl_lit"], "type": "code"}], "role": "item", "attrs": {"default": "0", "on": "detail", "type": "int"}, "extent": [14543, 14553], "container": true, "type": "attributes_item", "id": "gl_lit"}, {"body": [{"indent": 4, "type": "para", "extent": [14805, 15019], "text": ["If this detail attribute is not 0, all points will be rendered as sprites, even if they are connected to geometry.  Normally only unconnected points are rendered. This is currently ignored for guide geometry."]}], "indent": 0, "text": [{"text": ["gl_showallpoints"], "type": "code"}], "role": "item", "attrs": {"default": "0", "on": "detail", "type": "int"}, "extent": [14737, 14757], "container": true, "type": "attributes_item", "id": "gl_showallpoints"}, {"body": [{"indent": 4, "type": "para", "extent": [15086, 15229], "text": ["Controls the cusp angle used for generating normals when the geometry doesn\u2019t have any.  180 will produce entirely smooth point normals."]}], "indent": 0, "text": [{"text": ["vm_cuspangle"], "type": "code"}], "role": "item", "attrs": {"default": "60", "on": "detail", "type": "float"}, "extent": [15019, 15035], "container": true, "type": "attributes_item", "id": "vm_cuspangle"}], "container": true, "role": "item_group", "type": "attributes_item_group"}, {"indent": 0, "text": [" Particle attributes "], "type": "sep", "extent": [15229, 15259], "level": 4}, {"body": [{"body": [{"indent": 4, "type": "para", "extent": [15292, 15492], "text": ["The ", {"text": ["force"], "type": "code"}, " attribute on the current point. This is set/used by some particle DOPs. It represents a change to the particle\u2019s position computed by adding up all the forces acting on the particle."]}], "indent": 0, "text": [{"text": ["force"], "type": "code"}], "role": "item", "attrs": {"type": "vector"}, "extent": [15259, 15269], "container": true, "type": "attributes_item", "id": "force"}, {"body": [{"indent": 4, "type": "para", "extent": [15538, 15755], "text": ["Conventional name for an attribute containing each point\u2019s rest position, used by various nodes.\n    Some shaders can use this rather than ", {"text": ["P"], "type": "code"}, ", so procedural textures will stick even if you deform your geometry."]}], "indent": 0, "text": [{"text": ["rest"], "type": "code"}], "role": "item", "attrs": {"on": "point", "type": "vector"}, "extent": [15492, 15500], "container": true, "type": "attributes_item", "id": "rest"}, {"body": [{"indent": 4, "type": "para", "extent": [15788, 15913], "text": ["The ", {"text": ["torque"], "type": "code"}, " attribute on the current point. This is set/used by the ", {"text": ["Torque DOP"], "fullpath": "/nodes/dop/poptorque", "scheme": "Node", "type": "link", "value": "/nodes/dop/poptorque"}, " to spin particles."]}], "indent": 0, "text": [{"text": ["torque"], "type": "code"}], "role": "item", "attrs": {"type": "vector"}, "extent": [15755, 15765], "container": true, "type": "attributes_item", "id": "torque"}, {"body": [{"indent": 4, "type": "para", "extent": [15942, 16123], "text": ["Represents the up vector of a particle\u2019s local space. This is used for instancing geometry onto a point. You can overwrite this attribute to change the particle\u2019s orientation."]}], "indent": 0, "text": [{"text": ["up"], "type": "code"}], "role": "item", "attrs": {"type": "vector"}, "extent": [15913, 15919], "container": true, "type": "attributes_item", "id": "up"}, {"body": [{"indent": 4, "type": "para", "extent": [16155, 16250], "text": ["Obsolete, used by old POPs. The new DOP particle nodes use the ", {"text": ["force"], "type": "code"}, " attribute instead."]}], "indent": 0, "text": [{"text": ["accel"], "type": "code"}], "role": "item", "attrs": {"type": "vector"}, "extent": [16123, 16132], "container": true, "type": "attributes_item", "id": "accel"}, {"body": [{"indent": 4, "type": "para", "extent": [16287, 16362], "text": ["Obsolete. Used by old POPs to store the particle\u2019s previous position."]}], "indent": 0, "text": [{"text": ["backtrack"], "type": "code"}], "role": "item", "attrs": {"type": "vector4"}, "extent": [16250, 16263], "container": true, "type": "attributes_item", "id": "backtrack"}, {"body": [{"indent": 4, "type": "para", "extent": [16396, 16585], "text": ["Quaternion orientation of a particle. Allows fully specifying rotation, whereas ", {"text": ["up"], "type": "code"}, " only orients along a single axis. If this exists, it is used for instancing geometry onto a point."]}], "indent": 0, "text": [{"text": ["orient"], "type": "code"}], "role": "item", "attrs": {"type": "vector4"}, "extent": [16362, 16372], "container": true, "type": "attributes_item", "id": "orient"}, {"body": [{"indent": 4, "type": "para", "extent": [16616, 16733], "text": ["An additional offset-quaternion applied after all other attributes, used when instancing geometry onto a point."]}], "indent": 0, "text": [{"text": ["rot"], "type": "code"}], "role": "item", "attrs": {"type": "vector4"}, "extent": [16585, 16592], "container": true, "type": "attributes_item", "id": "rot"}, {"body": [{"indent": 4, "type": "para", "extent": [16763, 16875], "text": ["Detail attribute storing the largest particle ID, allowing Houdini to create new particle ids efficiently."]}], "indent": 0, "text": [{"text": ["nextid"], "type": "code"}], "role": "item", "attrs": {"type": "int"}, "extent": [16733, 16743], "container": true, "type": "attributes_item", "id": "nextid"}, {"body": [{"indent": 4, "type": "para", "extent": [16905, 17156], "text": ["A bit field encoding different pieces of information about a particle\u2019s state (for example, whether it\u2019s alive, whether it\u2019s stopped, whether it collided in the previous frame, and so on). Various particle DOPs read and write this attribute."]}, {"indent": 4, "type": "para", "extent": [17156, 17219], "text": ["The ", {"text": ["pstate"], "type": "code"}, " value is the sum of the following flags:"]}, {"body": [{"body": [{"indent": 4, "text": [{"text": ["0x01"], "type": "code"}, " "], "role": "td", "extent": [17219, 17232], "container": true, "type": "cell"}, {"body": [{"indent": 8, "type": "para", "extent": [17232, 17313], "text": ["Is a \"primary\" particle (not birthed from an existing\n        particle)."]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 4, "text": [{"text": ["0x02"], "type": "code"}, " "], "role": "td", "extent": [17313, 17326], "container": true, "type": "cell"}, {"body": [{"indent": 8, "type": "para", "extent": [17326, 17366], "text": ["Will die before the next frame."]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 4, "text": [{"text": ["0x04"], "type": "code"}, " "], "role": "td", "extent": [17366, 17379], "container": true, "type": "cell"}, {"body": [{"indent": 8, "type": "para", "extent": [17379, 17396], "text": ["Stopped."]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 4, "text": [{"text": ["0x08"], "type": "code"}, " "], "role": "td", "extent": [17396, 17409], "container": true, "type": "cell"}, {"body": [{"indent": 8, "type": "para", "extent": [17409, 17431], "text": ["Has collided."]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 4, "text": [{"text": ["0x10"], "type": "code"}, " "], "role": "td", "extent": [17431, 17444], "container": true, "type": "cell"}, {"body": [{"indent": 8, "type": "para", "extent": [17444, 17488], "text": ["Stuck to static or moving geometry."]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 4, "text": [{"text": ["0x20"], "type": "code"}, " "], "role": "td", "extent": [17488, 17501], "container": true, "type": "cell"}, {"body": [{"indent": 8, "type": "para", "extent": [17501, 17561], "text": ["Is associated with a rigid body dynamic simulation."]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 4, "text": [{"text": ["0x40"], "type": "code"}, " "], "role": "td", "extent": [17561, 17574], "container": true, "type": "cell"}, {"body": [{"indent": 8, "type": "para", "extent": [17574, 17590], "text": ["Active."]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 4, "text": [{"text": ["0x80"], "type": "code"}, " "], "role": "td", "extent": [17590, 17603], "container": true, "type": "cell"}, {"body": [{"indent": 8, "type": "para", "extent": [17603, 17645], "text": ["Motion is overridden by a CHOP."]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}], "type": "table", "thead": []}], "indent": 0, "text": [{"text": ["pstate"], "type": "code"}], "role": "item", "attrs": {"type": "int"}, "extent": [16875, 16885], "container": true, "type": "attributes_item", "id": "pstate"}], "container": true, "role": "item_group", "type": "attributes_item_group"}, {"indent": 0, "text": [" Shader overrides "], "type": "sep", "extent": [17645, 17672], "level": 4}, {"indent": 0, "type": "para", "extent": [17672, 17777], "text": ["Most shaders will use the override attributes to change how elements with these attributes are shaded."]}, {"body": [{"body": [{"indent": 4, "type": "para", "extent": [17806, 17884], "text": ["Diffuse color override. The viewport uses this to color OpenGL geometry."]}], "indent": 0, "text": [{"text": ["Cd"], "type": "code"}], "role": "item", "attrs": {"type": "vector"}, "extent": [17777, 17783], "container": true, "type": "attributes_item", "id": "cd"}, {"body": [{"indent": 4, "type": "para", "extent": [17915, 18009], "text": ["Alpha transparency override. The viewport uses this to set the alpha of OpenGL geometry."]}], "indent": 0, "text": [{"text": ["Alpha"], "type": "code"}], "role": "item", "attrs": {"type": "float"}, "extent": [17884, 17893], "container": true, "type": "attributes_item", "id": "alpha"}, {"body": [{"indent": 4, "type": "para", "extent": [18038, 18068], "text": ["Specular color override."]}], "indent": 0, "text": [{"text": ["Cs"], "type": "code"}], "role": "item", "attrs": {"type": "vector"}, "extent": [18009, 18015], "container": true, "type": "attributes_item", "id": "cs"}, {"body": [{"indent": 4, "type": "para", "extent": [18097, 18126], "text": ["Reflect color override."]}], "indent": 0, "text": [{"text": ["Cr"], "type": "code"}], "role": "item", "attrs": {"type": "vector"}, "extent": [18068, 18074], "container": true, "type": "attributes_item", "id": "cr"}, {"body": [{"indent": 4, "type": "para", "extent": [18155, 18185], "text": ["Transmit color override."]}], "indent": 0, "text": [{"text": ["Ct"], "type": "code"}], "role": "item", "attrs": {"type": "vector"}, "extent": [18126, 18132], "container": true, "type": "attributes_item", "id": "ct"}, {"body": [{"indent": 4, "type": "para", "extent": [18214, 18244], "text": ["Emission color override."]}], "indent": 0, "text": [{"text": ["Ce"], "type": "code"}], "role": "item", "attrs": {"type": "vector"}, "extent": [18185, 18191], "container": true, "type": "attributes_item", "id": "ce"}, {"body": [{"indent": 4, "type": "para", "extent": [18271, 18296], "text": ["Roughness override."]}], "indent": 0, "text": [{"text": ["rough"], "type": "code"}], "role": "item", "attrs": {"type": "float"}, "extent": [18244, 18253], "container": true, "type": "attributes_item", "id": "rough"}, {"body": [{"indent": 4, "type": "para", "extent": [18329, 18364], "text": ["Fresnel coefficient override."]}], "indent": 0, "text": [{"text": ["fresnel"], "type": "code"}], "role": "item", "attrs": {"type": "float"}, "extent": [18296, 18307], "container": true, "type": "attributes_item", "id": "fresnel"}, {"body": [{"indent": 4, "type": "para", "extent": [18396, 18428], "text": ["Shadow intensity override."]}], "indent": 0, "text": [{"text": ["shadow"], "type": "code"}], "role": "item", "attrs": {"type": "float"}, "extent": [18364, 18374], "container": true, "type": "attributes_item", "id": "shadow"}, {"body": [{"indent": 4, "type": "para", "extent": [18459, 18487], "text": ["Shadow bias override."]}], "indent": 0, "text": [{"text": ["sbias"], "type": "code"}], "role": "item", "attrs": {"type": "float"}, "extent": [18428, 18437], "container": true, "type": "attributes_item", "id": "sbias"}], "container": true, "role": "item_group", "type": "attributes_item_group"}, {"indent": 0, "text": [" Rendering attributes "], "type": "sep", "extent": [18487, 18518], "level": 4}, {"body": [{"body": [{"indent": 4, "type": "para", "extent": [18571, 18993], "text": ["The UV coordinates of the point/vertex. The first two elements of this vector contain the current U and V coordinates. Note that ", {"text": ["uv"], "type": "code"}, " is Houdini\u2019s conventional attribute name for storing texture coordinates. You can store texture coordinates in other attributes, so you can have multiple UV layouts on the same geometry. Most texture-related nodes have a field to let you specify the name of the UV attribute to use."]}], "indent": 0, "text": [{"text": ["uv"], "type": "code"}], "role": "item", "attrs": {"on": "point, vertex", "type": "vector"}, "extent": [18518, 18525], "container": true, "type": "attributes_item", "id": "uv"}, {"body": [{"indent": 4, "type": "para", "extent": [19028, 19128], "text": ["The node path to the material to use to shade this primitive. Overrides the object\u2019s material."]}], "indent": 0, "text": [{"text": ["material"], "type": "code"}], "role": "item", "attrs": {"type": "string"}, "extent": [18993, 19005], "container": true, "type": "attributes_item", "id": "material"}, {"body": [{"indent": 4, "type": "para", "extent": [19185, 19462], "text": ["The ", {"text": ["instance"], "type": "code"}, " attribute on the current point, containing a path to the geometry instanced on the point. This can be a file path to a geometry file, or an ", {"text": ["op:"], "type": "code"}, " path to a Geometry object or geometry node. You can overwrite this attribute to change the instanced geometry."]}], "indent": 0, "text": [{"text": ["instance"], "type": "code"}], "role": "item", "attrs": {"on": "detail, prim", "type": "string"}, "extent": [19128, 19140], "container": true, "type": "attributes_item", "id": "instance"}, {"body": [{"indent": 4, "type": "para", "extent": [19518, 19574], "text": ["Detail/primitive. The name of a RenderMan shader."]}], "indent": 0, "text": [{"text": ["rishade"], "type": "code"}], "role": "item", "attrs": {"on": "detail, prim", "type": "string"}, "extent": [19462, 19473], "container": true, "type": "attributes_item", "id": "rishade"}], "container": true, "role": "item_group", "type": "attributes_item_group"}], "indent": 0, "level": 1, "text": ["Common attributes"], "role": "section", "extent": [10975, 11005], "container": true, "type": "attributes_section", "id": "attributes"}, {"body": [{"body": [{"indent": 0, "role": "item", "type": "related_item", "extent": [19583, 19614], "text": [" ", {"text": "", "fullpath": "/dopparticles/attributes", "scheme": null, "type": "link", "value": "/dopparticles/attributes"}]}, {"indent": 0, "role": "item", "type": "related_item", "extent": [19614, 19641], "text": [" ", {"text": "", "fullpath": "/crowds/attributes", "scheme": null, "type": "link", "value": "/crowds/attributes"}]}], "container": true, "role": "item_group", "type": "related_item_group"}], "indent": 0, "level": 1, "text": "Related", "role": "section", "extent": [19574, 19583], "container": true, "type": "related_section", "id": "related"}], "summary": ["Describes how Houdini represents geometry using details, primitives, points, vertices, and attributes."], "type": "root", "attrs": {}, "title": ["Geometry attributes"]}