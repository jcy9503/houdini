{"body": [{"body": [{"body": [{"indent": 4, "type": "para", "extent": [60, 433], "text": ["Specifies the relative directory where the work generates intermediate files and output. The intermediate files are placed in a subdirectory. For the Local Scheduler or HQueue, typically ", {"text": ["$HIP"], "type": "code"}, " is used. For other schedulers, this should be a relative directory to ", {"text": ["Local Shared Root Path"], "type": "code"}, " and ", {"text": ["Remote Shared Root Path"], "type": "code"}, "; this path is then appended to these root paths."]}], "indent": 0, "text": ["Working Directory"], "attrs": {"id": "pdg_workingdir"}, "extent": [16, 35], "container": true, "type": "dt"}, {"body": [{"body": [{"body": [{"indent": 8, "type": "para", "extent": [481, 576], "text": ["If the ", {"text": ["PDG Path Map"], "fullpath": "/ref/panes/pdgpathmap", "scheme": null, "type": "link", "value": "/ref/panes/pdgpathmap"}, " exists, then it is applied to file paths."]}], "indent": 4, "text": ["Global"], "extent": [469, 481], "container": true, "type": "dt"}, {"body": [{"indent": 8, "type": "para", "extent": [586, 640], "text": ["Delocalizes paths using the ", {"text": ["PDG_DIR"], "type": "code"}, " token."]}], "indent": 4, "text": ["None"], "extent": [576, 586], "container": true, "type": "dt"}], "container": true, "type": "dt_group"}], "indent": 0, "text": ["Path Mapping"], "attrs": {"id": "pdg_mapmode"}, "extent": [433, 447], "container": true, "type": "dt"}, {"body": [{"indent": 4, "type": "para", "extent": [677, 830], "text": ["When on, specifies a custom mapping zone to apply to all jobs executed by this scheduler. Otherwise, the local platform is ", {"text": ["LINUX"], "type": "code"}, ", ", {"text": ["MAC"], "type": "code"}, " or ", {"text": ["WIN"], "type": "code"}, "."]}], "indent": 0, "text": ["Path Map Zone"], "attrs": {"id": "pdg_mapzone"}, "extent": [640, 655], "container": true, "type": "dt"}, {"body": [{"indent": 4, "type": "para", "extent": [893, 1096], "text": ["When enabled, PDG will check the output files of work items when the graph recooks, to see if the files still exist on disk. Work items that are missing output files will be dirtied and cook again."]}], "indent": 0, "text": ["Validate Outputs When Recooking"], "attrs": {"id": "pdg_validateoutputs"}, "extent": [830, 863], "container": true, "type": "dt"}, {"body": [{"indent": 4, "type": "para", "extent": [1163, 1501], "text": ["When enabled, PDG will look on disk for any expected work items outputs that were not explicitly reported when the work item cooked. Expected outputs for a work item are checkd immediately after the scheduler marks the work item as cooked. Output files that were reported by the work item normally while cooking will not be checked."]}], "indent": 0, "text": ["Check Expected Outputs on Disk"], "attrs": {"id": "pdg_checkexpectedoutputs"}, "extent": [1096, 1128], "container": true, "type": "dt"}, {"body": [{"indent": 4, "type": "para", "extent": [1539, 1619], "text": ["Sets the minimum time (in seconds) between calls to the ", {"text": ["onTick"], "type": "code"}, " callback."]}], "indent": 0, "text": ["Tick Period"], "attrs": {"id": "pdg_tickperiod"}, "extent": [1501, 1514], "container": true, "type": "dt"}, {"body": [{"indent": 4, "type": "para", "extent": [1662, 1743], "text": ["Sets the maximum number of ready item ", {"text": ["onSchedule"], "type": "code"}, " callbacks between ticks."]}], "indent": 0, "text": ["Max Items Per Tick"], "attrs": {"id": "pdg_maxitems"}, "extent": [1619, 1639], "container": true, "type": "dt"}, {"body": [{"indent": 4, "type": "para", "extent": [1793, 1914], "text": ["Specifies the absolute path to the mounted directory on the local machine at which the working directory is rooted."]}], "indent": 0, "text": ["Local Shared Root Path"], "attrs": {"id": "localsharedroot"}, "extent": [1743, 1767], "container": true, "type": "dt"}, {"body": [{"indent": 4, "type": "para", "extent": [1966, 2172], "text": ["When on, specifies the path to the mounted directory on client machines at which the working directory is rooted. This can include variables that the farm is set to resolve to platform-specific paths."]}], "indent": 0, "text": ["Remote Shared Root Path"], "attrs": {"id": "remotesharedroot"}, "extent": [1914, 1939], "container": true, "type": "dt"}, {"body": [{"indent": 4, "type": "para", "extent": [2221, 2287], "text": ["When on, overrides the callback server\u2019s default port range."]}], "indent": 0, "text": ["Override Port Range"], "attrs": {"id": "overrideportrange"}, "extent": [2172, 2193], "container": true, "type": "dt"}, {"body": [{"indent": 4, "type": "para", "extent": [2336, 2434], "text": ["Specifies the callback server\u2019s port range values to use when overriding the default values."]}], "indent": 0, "text": ["Callback Port Range"], "attrs": {"id": "callbackportrange"}, "extent": [2287, 2308], "container": true, "type": "dt"}], "container": true, "type": "dt_group"}, {"body": [{"indent": 0, "type": "para", "extent": [2471, 2727], "text": ["As part of the cook, a message queue (MQ) job is submitted. This job is used to communicate information from executing jobs back to the submitting machine. For this reason, your farm machines must be able to resolve the hostnames of other farm machines."]}, {"body": [{"body": [{"indent": 4, "type": "para", "extent": [2732, 2853], "text": ["This is as simple as editing the ", {"text": ["/etc/hosts"], "type": "code"}, " (Linux / macOS) or ", {"text": ["C:\\Windows\\System32\\Drivers\\etc\\hosts"], "type": "code"}, " (Windows)."]}], "indent": 0, "role": "item", "extent": [2727, 2732], "container": true, "type": "tip"}], "container": true, "role": "item_group", "type": "tip_group"}, {"indent": 0, "type": "para", "extent": [2853, 3010], "text": ["In addition, farm machines must ", {"text": ["not"], "type": "em"}, " have firewalls between them, or you need to use the ", {"text": ["Task Callback Port"], "type": "ui"}, " parameter to specify the open port to use."]}, {"indent": 0, "type": "para", "extent": [3010, 3283], "text": ["When the cook starts, the submitting machine connects to the farm machine that is running the MQ job. So farm machines also must ", {"text": ["not"], "type": "em"}, " have firewalls between them and the submitting machine, or you need to use the ", {"text": ["Relay Port"], "type": "ui"}, " parameter to specify the open port to use."]}, {"body": [{"body": [{"indent": 4, "type": "para", "extent": [3330, 3532], "text": ["When on, turns on the data layer server for the TOP job that will cook on the farm. This allows PilotPDG or other WebSocket clients to connect to the cooking job remotely to view the state of PDG."]}], "indent": 0, "text": ["Enable Server"], "attrs": {"id": "enabledatalayerserver"}, "extent": [3283, 3298], "container": true, "type": "dt"}, {"body": [{"indent": 4, "type": "para", "extent": [3572, 3640], "text": ["Determines which server port to use for the data layer server."]}, {"indent": 4, "type": "para", "extent": [3640, 3710], "text": ["This parameter is only available when ", {"text": ["Enable Server"], "type": "ui"}, " is ", {"text": ["on"], "type": "em"}, "."]}, {"body": [{"body": [{"indent": 8, "type": "para", "extent": [3725, 3803], "text": ["A free TCP port to use for the data layer server chosen by the node."]}], "indent": 4, "text": ["Automatic"], "extent": [3710, 3725], "container": true, "type": "dt"}, {"body": [{"indent": 8, "type": "para", "extent": [3815, 3898], "text": ["A custom TCP port to use for the data layer server specified by the user."]}, {"indent": 8, "type": "para", "extent": [3898, 4000], "text": ["This is useful when there is a firewall between the farm machine and the monitoring machine."]}], "indent": 4, "text": ["Custom"], "extent": [3803, 3815], "container": true, "type": "dt"}], "container": true, "type": "dt_group"}], "indent": 0, "text": ["Server Port"], "attrs": {"id": "usedatalayerport"}, "extent": [3532, 3545], "container": true, "type": "dt"}, {"body": [{"indent": 4, "type": "para", "extent": [4042, 4247], "text": ["When on, the node will try to send a command to create a remote visualizer when the job starts. If successful, a remote graph is created and it automatically connects to the server executing the job."]}, {"indent": 4, "type": "para", "extent": [4247, 4359], "text": ["The client submitting the job ", {"text": ["must"], "type": "em"}, " be visible to the server running the job or the connection will fail."]}, {"indent": 4, "type": "para", "extent": [4359, 4429], "text": ["This parameter is only available when ", {"text": ["Enable Server"], "type": "ui"}, " is ", {"text": ["on"], "type": "em"}, "."]}], "indent": 0, "text": ["Auto Connect"], "attrs": {"id": "createremotegraph"}, "extent": [4000, 4014], "container": true, "type": "dt"}, {"body": [{"indent": 4, "type": "para", "extent": [4476, 4633], "text": ["What to do when the TOP Cook finishes.  It may be useful to keep a job running so that it can be inspected by a wrangler using a Data Layer viewer."]}, {"body": [{"body": [{"indent": 8, "type": "para", "extent": [4648, 4685], "text": ["Exit the job as normal."]}], "indent": 4, "text": ["Terminate"], "extent": [4633, 4648], "container": true, "type": "dt"}, {"body": [{"indent": 8, "type": "para", "extent": [4709, 4816], "text": ["Keep the job running only if there is an error detected, the job will need to be killed manually."]}], "indent": 4, "text": ["Keep Open If Error"], "extent": [4685, 4709], "container": true, "type": "dt"}, {"body": [{"indent": 8, "type": "para", "extent": [4831, 4904], "text": ["Keep the job running.  The job will need to be killed manually."]}], "indent": 4, "text": ["Keep Open"], "extent": [4816, 4831], "container": true, "type": "dt"}], "container": true, "type": "dt_group"}], "indent": 0, "text": ["When Finished"], "attrs": {"id": "submitjobwhenfinished"}, "extent": [4429, 4444], "container": true, "type": "dt"}, {"body": [{"indent": 4, "type": "para", "extent": [4962, 5388], "text": ["When this option is enabled the scheduler will block the cook from completing if there are any failed work items in that scheduler. This makes it possible to manually retry those work items, by preventing the PDG graph cook from ending before failed items can be retried. A cook that is blocked on failed work items can still be canceled using the ESC key, the cancel button in the TOP task bar, or the cancel API method."]}], "indent": 0, "text": ["Block on Failed Work Items"], "attrs": {"id": "pdg_waitforfailures"}, "extent": [4904, 4932], "container": true, "type": "dt"}], "container": true, "type": "dt_group"}], "indent": 0, "level": 2, "text": ["Network Requirements"], "extent": [2434, 2471], "container": true, "type": "h", "id": "network"}], "type": "root", "attrs": {"type": "include"}}