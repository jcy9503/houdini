{"body": [{"indent": 0, "text": ["Collision Source"], "type": "title", "extent": [0, 21], "level": 0}, {"indent": 0, "type": "summary", "extent": [162, 232], "text": ["Creates geometry and VDB volumes for use with DOPs collisions."]}, {"indent": 0, "type": "para", "extent": [232, 684], "text": ["This node can be used to interpolate deforming geometry, calculate point\nvelocities, and create VDB Signed Distance volumes for fast and accurate DOPs\ncollisions, in particular with solvers such as ", {"text": ["FLIP"], "fullpath": "/nodes/dop/flipsolver", "scheme": "Node", "type": "link", "value": "/nodes/dop/flipsolver"}, " that\nrequire substepping and properly interpolated sub-frame geometry.  It is usually\nused in conjunction with a ", {"text": ["Static Object"], "fullpath": "/nodes/dop/staticobject", "scheme": "Node", "type": "link", "value": "/nodes/dop/staticobject"}, " DOP as set up\nby the ", {"text": ["Deforming Object"], "fullpath": "/shelf/deformingobject", "scheme": null, "type": "link", "value": "/shelf/deformingobject"}, " shelf tool."]}, {"indent": 0, "type": "para", "extent": [684, 894], "text": ["If the input geometry is deforming, it must have a consistent number and\nordering of points for proper interpolation to sub-frames.  The output of this\nnode is a combination of named geometry and VDB volumes."]}, {"body": [{"body": [{"indent": 4, "type": "para", "extent": [900, 1307], "text": ["This SOP does not support calculating point velocities for \n    ", {"text": ["packed primitives"], "fullpath": "/model/packed", "scheme": null, "type": "link", "value": "/model/packed"}, " such as ", {"text": ["Alembic"], "fullpath": "/io/alembic", "scheme": null, "type": "link", "value": "/io/alembic"}, " files\n    or ", {"text": ["crowd agents"], "fullpath": "/crowds/agents", "scheme": null, "type": "link", "value": "/crowds/agents"}, ".  Use an ", {"text": ["Unpack"], "fullpath": "/nodes/sop/unpack", "scheme": "Node", "type": "link", "value": "/nodes/sop/unpack"}, " SOP to unpack\n    the geometry before sending into this node.  The ", {"text": ["Deforming Object"], "fullpath": "/shelf/deformingobject", "scheme": null, "type": "link", "value": "/shelf/deformingobject"}, "\n    shelf tool tries to detect packed geometry and automatically inserts an Unpack SOP."]}], "indent": 0, "role": "item", "extent": [894, 900], "container": true, "type": "note"}], "container": true, "role": "item_group", "type": "note_group"}, {"body": [{"body": [{"indent": 4, "type": "para", "extent": [1312, 1852], "text": ["If a collision object has both deforming SOP-level geometry ", {"text": ["and"], "type": "em"}, " transformations at the\n    Object-level, it can be helpful to create a separate non-transformed ", {"text": ["Geometry"], "fullpath": "/nodes/obj/geo", "scheme": "Node", "type": "link", "value": "/nodes/obj/geo"}, "\n    object and ", {"text": ["Object Merge"], "fullpath": "/nodes/sop/object_merge", "scheme": "Node", "type": "link", "value": "/nodes/sop/object_merge"}, " the collision object into it, with the\n    ", {"text": ["Transform"], "type": "ui"}, " parameter on the Object Merge set to ", {"text": ["Into This Object"], "type": "ui"}, ". By baking the\n    Object-level transformations into the geometry this way, it is easier to visualize the\n    point velocities and ensure they are correct before use in simulations."]}], "indent": 0, "role": "item", "extent": [1307, 1312], "container": true, "type": "tip"}], "container": true, "role": "item_group", "type": "tip_group"}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "extent": [1872, 1963], "text": ["Specifies the primitives for which to generate collision geometry and\n    collisions."]}], "indent": 0, "text": ["Group"], "role": "item", "extent": [1864, 1872], "container": true, "type": "parameters_item"}], "container": true, "role": "item_group", "type": "parameters_item_group"}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "extent": [1996, 2050], "text": ["Include the geometry in the output of this node."]}], "indent": 0, "text": ["Output Geometry"], "role": "item", "extent": [1978, 1996], "container": true, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [2068, 2204], "text": ["Display the output geometry in the viewport.  Turning this option off can\n    make it easier to visualize just the output volumes."]}], "indent": 0, "text": ["Display Geometry"], "role": "item", "extent": [2050, 2068], "container": true, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [2219, 2314], "text": ["The primitives in the output geometry will have a ", {"text": ["name"], "type": "code"}, " attribute set\n    to this value."]}], "indent": 0, "text": ["Geometry Name"], "role": "item", "extent": [2204, 2219], "container": true, "type": "parameters_item"}], "container": true, "role": "item_group", "type": "parameters_item_group"}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "extent": [2359, 2765], "text": ["Cooks the input geometry at the start and end of the nearest integer\n    frames, then blends between the two geometries according to the fractional\n    position within the frame.  This option can be used to interpolate\n    geometry that is defined only at whole frames, to be used with solvers\n    that require sub-frame geometry.  See the ", {"text": ["TimeBlend"], "fullpath": "/nodes/sop/timeblend", "scheme": "Node", "type": "link", "value": "/nodes/sop/timeblend"}, "\n    SOP for more information."]}], "indent": 0, "text": ["Blend Between Frames"], "role": "item", "extent": [2336, 2359], "container": true, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [2783, 2939], "text": ["Determines if the first frame should be clamped. If so, any\n    evaluations before this frame value will instead evaluate at\n    this frame value."]}], "indent": 0, "text": ["Hold First Frame"], "role": "item", "extent": [2765, 2783], "container": true, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [2956, 3106], "text": ["Determines if the last frame should be clamped. If so, any\n    evaluations after this frame value will instead evaluate at this\n    frame value."]}], "indent": 0, "text": ["Hold Last Frame"], "role": "item", "extent": [2939, 2956], "container": true, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [3132, 3450], "text": ["Geometry interpolation and point velocity calculation require cooking of\n    the input geometry at several different points in time.  When this option\n    is enabled, a few frames of the input geometry surrounding the current\n    frame are cached, accelerating these computations at the cost of extra\n    memory."]}], "indent": 0, "text": ["Cache Geometry in Memory"], "role": "item", "extent": [3106, 3132], "container": true, "type": "parameters_item"}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 3, "text": ["Interpolation"], "extent": [2314, 2336], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "extent": [3483, 3538], "text": ["The method used to compute point velocity values."]}, {"body": [{"body": [{"indent": 8, "type": "para", "extent": [3548, 3592], "text": ["No point velocities are calculated."]}], "indent": 4, "text": ["None"], "extent": [3538, 3548], "container": true, "type": "dt"}, {"body": [{"indent": 8, "type": "para", "extent": [3617, 3725], "text": ["Calculate velocities using the difference between the previous frame\n        and the current frame."]}], "indent": 4, "text": ["Backward Difference"], "extent": [3592, 3617], "container": true, "type": "dt"}, {"body": [{"indent": 8, "type": "para", "extent": [3749, 3899], "text": ["Calculate velocities using the difference between the previous frame\n        and the next frame.  This method is generally the most accurate."]}], "indent": 4, "text": ["Central Difference"], "extent": [3725, 3749], "container": true, "type": "dt"}, {"body": [{"indent": 8, "type": "para", "extent": [3923, 4028], "text": ["Calculate velocities using the difference between the current\n        frame and the next frame."]}], "indent": 4, "text": ["Forward Difference"], "extent": [3899, 3923], "container": true, "type": "dt"}], "container": true, "type": "dt_group"}], "indent": 0, "text": ["Approximation"], "role": "item", "extent": [3467, 3483], "container": true, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [4044, 4253], "text": ["When computing velocity the resulting velocity will be scaled by this\n    constant.  Note there is an internal scale of ", {"text": ["$FPS"], "type": "code"}, " to convert the\n    measured change over a frame into a change over a second."]}], "indent": 0, "text": ["Velocity Scale"], "role": "item", "extent": [4028, 4044], "container": true, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [4279, 4405], "text": ["The difference in orientation of successive frames will be used to\n    compute an angular velocity, ", {"text": ["w"], "type": "code"}, ", for the points."]}], "indent": 0, "text": ["Compute Angular Velocity"], "role": "item", "extent": [4253, 4279], "container": true, "type": "parameters_item"}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 3, "text": ["Velocity"], "extent": [3450, 3467], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "extent": [4437, 4878], "text": ["For deforming collisions, DOPs reads velocities from the nearest points\n    to any collision event.  If the input geometry consists of large\n    primitives with few points (e.g. a large box), the nearest input point\n    might not be a good sample of the object\u2019s velocity.  Enabling this option\n    will scatter points on the input geometry to better represent the\n    point velocities, to the accuracy controlled by ", {"text": ["Density Scale"], "type": "ui"}, "."]}], "indent": 0, "text": ["Scatter Points"], "role": "item", "extent": [4420, 4437], "container": true, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [4894, 4926], "text": ["Show the scattered points."]}], "indent": 0, "text": ["Display Points"], "role": "item", "extent": [4878, 4894], "container": true, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [4941, 5129], "text": ["Measure the current point density then scale the scattering density so\n    there are approximately this many points per volume voxel as specified\n    by the ", {"text": ["Voxel Size"], "type": "ui"}, " parameter."]}], "indent": 0, "text": ["Density Scale"], "role": "item", "extent": [4926, 4941], "container": true, "type": "parameters_item"}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 3, "text": ["Points"], "extent": [4405, 4420], "container": true, "type": "h", "id": null}], "indent": 0, "level": 2, "text": ["Geometry"], "extent": [1963, 1978], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "extent": [5158, 5281], "text": ["Create a VDB Signed Distance volume from the input geometry primitives\n    and include it in the output of this node."]}], "indent": 0, "text": ["Output Volume"], "role": "item", "extent": [5142, 5158], "container": true, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [5297, 5422], "text": ["Show the volume in the viewport.  Turning this option off can\n    make it easier to visualize just the output geometry."]}], "indent": 0, "text": ["Display Volume"], "role": "item", "extent": [5281, 5297], "container": true, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [5435, 5503], "text": ["The VDB volume will have a ", {"text": ["name"], "type": "code"}, " attribute set to this value."]}], "indent": 0, "text": ["Volume Name"], "role": "item", "extent": [5422, 5435], "container": true, "type": "parameters_item"}], "container": true, "role": "item_group", "type": "parameters_item_group"}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "extent": [5533, 5602], "text": ["The size in world space of the voxels in the output VDB volume."]}], "indent": 0, "text": ["Voxel Size"], "role": "item", "extent": [5520, 5533], "container": true, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [5613, 5684], "text": ["How many voxels outside the surface to fill in the generated VDB."]}], "indent": 0, "text": ["Bandwidth"], "role": "item", "extent": [5602, 5613], "container": true, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [5699, 5874], "text": ["Fill all voxels inside the surface with ", {"text": ["1"], "type": "code"}, ", not just the voxels near\n    the surface. This requires an airtight surface and takes considerably\n    more memory and time."]}], "indent": 0, "text": ["Fill Interior"], "role": "item", "extent": [5684, 5699], "container": true, "type": "parameters_item"}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 3, "text": ["Creation"], "extent": [5503, 5520], "container": true, "type": "h", "id": null}], "indent": 0, "level": 2, "text": ["Volume"], "extent": [5129, 5142], "container": true, "type": "h", "id": null}], "indent": 0, "level": 1, "text": "Parameters", "role": "section", "extent": [1852, 1864], "container": true, "type": "parameters_section", "id": "parameters"}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "extent": [5898, 5967], "text": ["The geometry from which to interpolate and create VDB volumes."]}], "indent": 0, "text": ["Input Geometry"], "extent": [5882, 5898], "container": true, "type": "dt"}], "container": true, "type": "dt_group"}], "indent": 0, "level": 1, "text": "Inputs", "role": "section", "extent": [5874, 5882], "container": true, "type": "inputs_section", "id": "inputs"}, {"body": [{"body": [{"indent": 4, "blevel": 6, "type": "bullet", "extent": [5976, 6006], "text": [{"text": "", "fullpath": "/nodes/dop/staticobject", "scheme": "Node", "type": "link", "value": "/nodes/dop/staticobject"}]}, {"indent": 4, "blevel": 6, "type": "bullet", "extent": [6006, 6033], "text": [{"text": "", "fullpath": "/nodes/sop/timeblend", "scheme": "Node", "type": "link", "value": "/nodes/sop/timeblend"}]}, {"indent": 4, "blevel": 6, "type": "bullet", "extent": [6033, 6056], "text": [{"text": "", "fullpath": "/nodes/sop/trail", "scheme": "Node", "type": "link", "value": "/nodes/sop/trail"}]}, {"indent": 4, "blevel": 6, "type": "bullet", "extent": [6056, 6089], "text": [{"text": "", "fullpath": "/nodes/sop/vdbfrompolygons", "scheme": "Node", "type": "link", "value": "/nodes/sop/vdbfrompolygons"}]}], "container": true, "type": "bullet_group"}], "indent": 0, "level": 1, "text": "Related", "role": "section", "extent": [5967, 5976], "container": true, "type": "related_section", "id": "related"}], "summary": ["Creates geometry and VDB volumes for use with DOPs collisions."], "type": "root", "attrs": {"version": "2.0", "tags": "rbd, dynamics, source", "since": "16.0", "namespace": null, "internal": "collisionsource", "context": "sop", "type": "node", "icon": "SHELF/deforming_object"}, "title": ["Collision Source"]}