{"body": [{"indent": 0, "text": ["Voronoi Fracture"], "type": "title", "extent": [122, 143], "level": 0}, {"indent": 0, "type": "summary", "extent": [143, 256], "text": ["Fractures the input geometry by performing a Voronoi decomposition of space around the input cell points"]}, {"indent": 0, "type": "para", "extent": [256, 796], "text": ["The Voronoi Fracture SOP takes two primary inputs: the mesh to fracture, and the points around which to build each Voronoi cell. Often these points will be generated by either the ", {"text": ["Scatter SOP"], "fullpath": "/nodes/sop/scatter", "scheme": "Node", "type": "link", "value": "/nodes/sop/scatter"}, ", or the ", {"text": ["Points From Volume SOP"], "fullpath": "/nodes/sop/pointsfromvolume", "scheme": "Node", "type": "link", "value": "/nodes/sop/pointsfromvolume"}, ", but any source of points will work.\nFor a solid fracture (where the interior surface of the object is built for each piece) it is very useful to have all the points reside within the volume, in which case one fractured piece will be generated for for each cell point."]}, {"body": [{"body": [{"indent": 0, "blevel": 2, "type": "bullet", "extent": [807, 1175], "text": ["Using points scattered in a density volume generated from the geometry using ", {"text": ["IsoOffset"], "fullpath": "/nodes/sop/isooffset", "scheme": "Node", "type": "link", "value": "/nodes/sop/isooffset"}, " is a flexible way to generate cell points, as you can modulate the density in the volume before scattering to get more points within particular regions of the object.\nWhere there is higher point density, the Fracture SOP will generate more, smaller pieces."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [1175, 1276], "text": ["Mesh complexity slows down fracturing more than anything. PolyReduce before fracturing if you can."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [1276, 1511], "text": ["If you have problems with insufficient point density in long appendages or something in the input object, try ", {"text": ["scattering"], "fullpath": "/nodes/sop/scatter", "scheme": "Node", "type": "link", "value": "/nodes/sop/scatter"}, " points after using ", {"text": ["IsoOffset"], "fullpath": "/nodes/sop/isooffset", "scheme": "Node", "type": "link", "value": "/nodes/sop/isooffset"}, " and scaling the density up in those areas."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [1511, 1648], "text": ["The ", {"text": ["RBD Interior Detail SOP"], "fullpath": "/nodes/sop/rbdinteriordetail", "scheme": "Node", "type": "link", "value": "/nodes/sop/rbdinteriordetail"}, " can be used to create high resolution pieces with detailed interior surfaces."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [1648, 1758], "text": ["The ", {"text": ["RBD Cluster SOP"], "fullpath": "/nodes/sop/rbdcluster", "scheme": "Node", "type": "link", "value": "/nodes/sop/rbdcluster"}, " can be used to create larger clusters from the fractured pieces."]}], "container": true, "type": "bullet_group"}], "indent": 0, "level": 2, "text": ["Tips"], "extent": [796, 807], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "extent": [1789, 1880], "text": ["The polygonal geometry that will be fractured according to the Voronoi decomposition."]}], "indent": 0, "text": ["Geometry to Fracture"], "extent": [1766, 1789], "container": true, "type": "dt"}, {"body": [{"indent": 4, "type": "para", "extent": [1906, 2007], "text": ["Input points, where each point represents a Voronoi cell around which to fracture the geometry."]}], "indent": 0, "text": ["Points for Voronoi Cells"], "extent": [1880, 1906], "container": true, "type": "dt"}], "container": true, "type": "dt_group"}], "indent": 0, "level": 1, "text": "Inputs", "role": "section", "extent": [1758, 1766], "container": true, "type": "inputs_section", "id": "inputs"}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "extent": [2037, 2076], "text": ["The fractured polygonal geometry."]}], "indent": 0, "text": ["Fractured Geometry"], "extent": [2016, 2037], "container": true, "type": "dt"}, {"body": [{"indent": 4, "type": "para", "extent": [2097, 2280], "text": ["Geometry containing a point for each piece, and polygon lines connecting pieces that are adjacent. This is useful for creating a ", {"text": ["constraint network"], "fullpath": "/nodes/dop/constraintnetwork", "scheme": "Node", "type": "link", "value": "/nodes/dop/constraintnetwork"}, "."]}], "indent": 0, "text": ["Constraint Geometry"], "extent": [2076, 2097], "container": true, "type": "dt"}], "container": true, "type": "dt_group"}], "indent": 0, "level": 1, "text": "Outputs", "role": "section", "extent": [2007, 2016], "container": true, "type": "outputs_section", "id": "outputs"}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "extent": [2300, 2408], "text": ["The geometry to be fractured.\n    If no group is specified, the full input geometry will be fractured."]}], "indent": 0, "text": ["Group"], "role": "item", "extent": [2292, 2300], "container": true, "type": "parameters_item"}], "container": true, "role": "item_group", "type": "parameters_item_group"}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "extent": [2450, 2646], "text": ["Creates faces on the interior of the geometry when performing the cutting.\n    This should typically be disabled when fracturing open surfaces, or to create a thin shell from a solid object."]}], "indent": 0, "text": ["Create Interior Surfaces"], "role": "item", "extent": [2423, 2450], "container": true, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [2682, 2802], "text": ["Specifies how the ", {"text": ["name"], "type": "code"}, " primitive attribute (which identifies the primitives belonging to each piece) is created."]}, {"body": [{"body": [{"indent": 8, "type": "para", "extent": [2817, 2902], "text": ["Constructs the name by combining the ", {"text": ["Piece Prefix"], "type": "ui"}, " with the piece number."]}], "indent": 4, "text": ["Overwrite"], "extent": [2802, 2817], "container": true, "type": "dt"}, {"body": [{"indent": 8, "type": "para", "extent": [2914, 3174], "text": ["If the original geometry already has a ", {"text": ["name"], "type": "code"}, " primitive attribute, it is prefixed with the ", {"text": ["Fracture Namespace"], "type": "ui"}, " and then the ", {"text": ["Piece Prefix"], "type": "ui"}, " and piece number are appended to it.\n        This is useful when performing multiple levels of fracturing."]}], "indent": 4, "text": ["Append"], "extent": [2902, 2914], "container": true, "type": "dt"}], "container": true, "type": "dt_group"}], "indent": 0, "text": ["Name Attribute"], "role": "item", "attrs": {"id": "namemethod"}, "extent": [2646, 2662], "container": true, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [3221, 3421], "text": ["Adds a prefix to the name of each input piece when ", {"text": ["Name Attribute"], "type": "ui"}, " is set to ", {"text": ["Append"], "type": "ui"}, ".\n    This can be useful for avoiding duplicate piece names or grouping the new pieces that are created."]}], "indent": 0, "text": ["Fracture Namespace"], "role": "item", "attrs": {"id": "fracturenamespace"}, "extent": [3174, 3194], "container": true, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [3455, 3530], "text": ["The prefix applied to the name of each piece created by the fracture."]}], "indent": 0, "text": ["Piece Prefix"], "role": "item", "attrs": {"id": "nameprefix"}, "extent": [3421, 3435], "container": true, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [3588, 3700], "text": ["Computes vertex normals on the edges of the interior geometry, so that they will have a cusped appearance."]}], "indent": 0, "text": ["Compute Interior Normals"], "role": "item", "attrs": {"id": "computeinteriornormals"}, "extent": [3530, 3556], "container": true, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [3748, 3896], "text": ["Computes vertex normals on the edges of the interior geometry with angles greater than this angle, so that they will have a cusped appearance."]}], "indent": 0, "text": ["Interior Cusp Angle"], "role": "item", "attrs": {"id": "interiorcuspangle"}, "extent": [3700, 3721], "container": true, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [3946, 4025], "text": ["Specifies how to compute or update vertex normals for the input geometry."]}, {"body": [{"body": [{"indent": 8, "type": "para", "extent": [4056, 4190], "text": ["Only compute vertex normals if the input geometry does not already have normals and ", {"text": ["Compute Interior Normals"], "type": "ui"}, " is enabled."]}], "indent": 4, "text": ["Preserve Existing Normals"], "extent": [4025, 4056], "container": true, "type": "dt"}, {"body": [{"indent": 8, "type": "para", "extent": [4213, 4276], "text": ["Always compute vertex normals for the input geometry."]}], "indent": 4, "text": ["Recompute Normals"], "extent": [4190, 4213], "container": true, "type": "dt"}, {"body": [{"indent": 8, "type": "para", "extent": [4304, 4451], "text": ["Do not compute normals for the input geometry. If ", {"text": ["Compute Interior Normals"], "type": "ui"}, " is still enabled, though, smooth normals will be computed."]}], "indent": 4, "text": ["Do Not Compute Normals"], "extent": [4276, 4304], "container": true, "type": "dt"}], "container": true, "type": "dt_group"}], "indent": 0, "text": ["Exterior Normals"], "role": "item", "attrs": {"id": "computeexteriornormals"}, "extent": [3896, 3914], "container": true, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [4499, 4644], "text": ["Computes vertex normals on the edges of the input geometry with angles greater than this angle, so that they will have a cusped appearance."]}], "indent": 0, "text": ["Exterior Cusp Angle"], "role": "item", "attrs": {"id": "exteriorcuspangle"}, "extent": [4451, 4472], "container": true, "type": "parameters_item"}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 2, "text": ["Pieces"], "extent": [2408, 2423], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"indent": 4, "type": "para", "extent": [4720, 5030], "text": ["Specifies a prefix for the attribute or group names specified by the ", {"text": ["Primitive Piece"], "type": "ui"}, ", ", {"text": ["Primitive Cell Point"], "type": "ui"}, ", ", {"text": ["Primitive Clip Piece"], "type": "ui"}, ", ", {"text": ["Interior Group"], "type": "ui"}, ", and ", {"text": ["Exterior Group"], "type": "ui"}, " parameters.\n    This can make it easier to create unique attribute names when performing multiple levels of fracturing."]}], "indent": 0, "text": ["Attribute Name Prefix"], "role": "item", "attrs": {"id": "attribnameprefix"}, "extent": [4670, 4694], "container": true, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [5068, 5168], "text": ["The name of the attribute containing the piece number with which each primitive is associated."]}], "indent": 0, "text": ["Primitive Piece"], "role": "item", "attrs": {"id": "pieceattrib"}, "extent": [5030, 5047], "container": true, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [5190, 5295], "text": ["The name of the attribute on primitives that will store which of the fracture points it comes from."]}], "indent": 0, "text": ["Primitive Cell Point"], "role": "item", "extent": [5168, 5190], "container": true, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [5317, 5441], "text": ["The name of the attribute on interior surface primitives that corresponds to the other piece adjacent at that surface."]}], "indent": 0, "text": ["Primitive Clip Piece"], "role": "item", "extent": [5295, 5317], "container": true, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [5480, 5573], "text": ["The group containing any primitives in the interior surfaces created during fracturing."]}], "indent": 0, "text": ["Interior Group"], "role": "item", "attrs": {"id": "interiorgroup"}, "extent": [5441, 5457], "container": true, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [5612, 5685], "text": ["The group containing the primitives in the original input geometry."]}], "indent": 0, "text": ["Exterior Group"], "role": "item", "attrs": {"id": "exteriorgroup"}, "extent": [5573, 5589], "container": true, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [5734, 6341], "text": ["If the interior and exterior groups already exist on the geometry from a previous fracture, the new interior primitives will be added to the interior group and the original exterior group will be preserved.\n    This behavior results in an interior group that contains all of the interior primitives created by multiple fracture operations (which can be useful for the ", {"text": ["RBD Interior Detail SOP"], "fullpath": "/nodes/sop/rbdinteriordetail", "scheme": "Node", "type": "link", "value": "/nodes/sop/rbdinteriordetail"}, ").\n    Otherwise, the interior group will be overwritten to only contain the interior primitives added by this node, and the exterior group will contain all of the input primitives."]}], "indent": 0, "text": ["Merge with Existing Groups"], "role": "item", "attrs": {"id": "mergegroups"}, "extent": [5685, 5713], "container": true, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [6369, 6447], "text": ["Copy attributes from the input cell points to the output piece geometry."]}], "indent": 0, "text": ["Copy Cell Point Attributes"], "role": "item", "extent": [6341, 6369], "container": true, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [6464, 6557], "text": ["The attributes to copy from the cell points to the points of the output piece geometry."]}], "indent": 0, "text": ["To Piece Points"], "role": "item", "extent": [6447, 6464], "container": true, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [6578, 6675], "text": ["The attributes to copy from the cell points to the primitives of the output piece geometry."]}], "indent": 0, "text": ["To Piece Primitives"], "role": "item", "extent": [6557, 6578], "container": true, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [6697, 6795], "text": ["The attributes to copy from the cell points to the points of the output constraint geometry."]}], "indent": 0, "text": ["To Constraint Points"], "role": "item", "extent": [6675, 6697], "container": true, "type": "parameters_item"}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 2, "text": ["Output Attributes"], "extent": [4644, 4670], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"body": [{"body": [{"body": [{"indent": 8, "type": "para", "extent": [6840, 6940], "text": ["Determine whether the input points are 1D, 2D, or 3D and generate a triangulation for them."]}], "indent": 4, "text": ["Auto Detect"], "extent": [6823, 6840], "container": true, "type": "dt"}, {"body": [{"indent": 8, "type": "para", "extent": [6948, 6994], "text": ["Assume points are 2D and triangulate."]}], "indent": 4, "text": ["2D"], "extent": [6940, 6948], "container": true, "type": "dt"}, {"body": [{"indent": 8, "type": "para", "extent": [7002, 7051], "text": ["Assume points are 3D and tetrahedralize."]}], "indent": 4, "text": ["3D"], "extent": [6994, 7002], "container": true, "type": "dt"}, {"body": [{"indent": 8, "type": "para", "extent": [7069, 7129], "text": ["Use an existing triangulation on the input points."]}], "indent": 4, "text": ["Use Existing"], "extent": [7051, 7069], "container": true, "type": "dt"}], "container": true, "type": "dt_group"}], "indent": 0, "text": ["Triangulation"], "role": "item", "extent": [6807, 6823], "container": true, "type": "parameters_item"}, {"body": [{"body": [{"body": [{"indent": 8, "type": "para", "extent": [7163, 7232], "text": ["Do not further partition pieces into groups by connectivity."]}], "indent": 4, "text": ["None"], "extent": [7153, 7163], "container": true, "type": "dt"}, {"body": [{"indent": 12, "type": "para", "extent": [7263, 7730], "text": ["Normally each input cell point will create one output piece. However, with concave objects this can mean that disconnected pieces of geometry are placed in the same piece. \n            Enabling this option will further divide the pieces into separate, connected groups of geometry. This option allows the piece numbers to be overwritten by this operation, which is fast and acceptable if you don\u2019t need the piece numbers to match the input point numbers."]}], "indent": 4, "text": ["Overwrite Piece Numbering"], "extent": [7232, 7263], "container": true, "type": "dt"}, {"body": [{"indent": 8, "type": "para", "extent": [7760, 7878], "text": ["This option uses a slower algorithm to ensure that piece numbers remain consistent with input point numbers."]}], "indent": 4, "text": ["Maintain Piece Numbering"], "extent": [7730, 7760], "container": true, "type": "dt"}], "container": true, "type": "dt_group"}], "indent": 0, "text": ["Connectivity Partition"], "role": "item", "extent": [7129, 7153], "container": true, "type": "parameters_item"}, {"body": [{"indent": 4, "type": "para", "extent": [7896, 8050], "text": ["Offsets the cut plane between adjacent cell points before cutting.\n    Increasing this has the effect of putting space between each fractured piece."]}], "indent": 0, "text": ["Cut Plane Offset"], "role": "item", "extent": [7878, 7896], "container": true, "type": "parameters_item"}], "container": true, "role": "item_group", "type": "parameters_item_group"}], "indent": 0, "level": 2, "text": ["Cut"], "extent": [6795, 6807], "container": true, "type": "h", "id": null}], "indent": 0, "level": 1, "text": "Parameters", "role": "section", "extent": [2280, 2292], "container": true, "type": "parameters_section", "id": "parameters"}, {"body": [{"body": [{"indent": 4, "blevel": 6, "type": "bullet", "extent": [8059, 8094], "text": [{"text": "", "fullpath": "/nodes/sop/rbdinteriordetail", "scheme": "Node", "type": "link", "value": "/nodes/sop/rbdinteriordetail"}]}, {"indent": 4, "blevel": 6, "type": "bullet", "extent": [8094, 8125], "text": [{"text": ["Shatter"], "fullpath": "/shelf/shatter", "scheme": null, "type": "link", "value": "/shelf/shatter"}]}, {"indent": 4, "blevel": 6, "type": "bullet", "extent": [8125, 8202], "text": [{"text": ["How to control the effects of voronoi fracture"], "fullpath": "/dyno/voronoifracture", "scheme": null, "type": "link", "value": "/dyno/voronoifracture"}]}], "container": true, "type": "bullet_group"}], "indent": 0, "level": 1, "text": "Related", "role": "section", "extent": [8050, 8059], "container": true, "type": "related_section", "id": "related"}], "summary": ["Fractures the input geometry by performing a Voronoi decomposition of space around the input cell points"], "type": "root", "attrs": {"version": "2.0", "tags": "break", "since": "17.0", "namespace": null, "internal": "voronoifracture", "context": "sop", "type": "node", "icon": "SOP/voronoifracture"}, "title": ["Voronoi Fracture"]}