{"body": [{"indent": 0, "text": ["Tool scripts"], "type": "title", "extent": [0, 17], "level": 0}, {"indent": 0, "type": "summary", "extent": [17, 77], "text": ["How to write Python scripts for shelf/asset tools."]}, {"body": [{"indent": 0, "type": "para", "extent": [92, 374], "text": ["A tool script runs when you click a shelf tool or choose a tool from a tab menu in a viewer or network editor. Tools can do something simple, like change a setting, or perform complex actions like running scripted interactions with the user and using the results to create nodes."]}, {"indent": 0, "type": "para", "extent": [374, 435], "text": ["There are two places in Houdini you can write tool scripts:"]}, {"body": [{"indent": 0, "blevel": 2, "type": "bullet", "extent": [435, 669], "text": ["In an asset, you can embed tools for creating and/or editing the asset inside the asset. The user can add custom tools to their shelf tabs. The tool script is also used to create the asset node in the viewer or the network editor."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [669, 848], "text": ["You can create custom tools directly on the shelf (not embedded in an asset). This script may create or a node or perform any other actions possible through Python scripting."]}], "container": true, "type": "bullet_group"}], "indent": 0, "level": 2, "text": ["Overview"], "extent": [77, 92], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"indent": 0, "blevel": 2, "type": "bullet", "extent": [860, 1120], "text": ["When you create an asset, Houdini gives it a default tool with a generic script that handles basic interaction. You don\u2019t need to modify the script unless you want to customize how the tool interacts with the user (see also ", {"text": ["Python states"], "fullpath": "/hom/python_states", "scheme": null, "type": "link", "value": "python_states"}, ")."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [1120, 1523], "text": ["When you drag a node onto the shelf, Houdini automatically creates a shelf item to create that type of node. It does ", {"text": ["not"], "type": "strong"}, " use your default tool script in the new shelf tool, but instead uses a generic script. If your asset has a tool with custom interaction, you should add that tool to the shelf instead of dragging the node. See ", {"text": ["how to customize the shelf"], "fullpath": "/shelf/customize", "scheme": null, "type": "link", "value": "/shelf/customize"}, " for more information."]}, {"body": [{"indent": 4, "type": "para", "extent": [1760, 2055], "text": ["To avoid recooking the current frame, you can call ", {"text": "", "value": "/hom/hou/setSimulationEnabled", "fallback_text": "hou.setSimulationEnabled", "fullpath": "/hom/hou/setSimulationEnabled", "scheme": "Hom", "type": "link"}, " to disable the simulation for the duration of your operation.  Make sure you record the initial simulation state (", {"text": "", "value": "/hom/hou/simulationEnabled", "fallback_text": "hou.simulationEnabled", "fullpath": "/hom/hou/simulationEnabled", "scheme": "Hom", "type": "link"}, ") before turning it off, and restore it at the end of the script."]}], "indent": 0, "text": ["While running shelf scripts Houdini is still \"Live\".  This is most noticeable if you acquire DOP Objects and then change the DOP Network.  After changing the DOP Network, the current frame will recook and invalidate your DOP Objects."], "extent": [1523, 1760], "container": true, "blevel": 2, "type": "bullet"}], "container": true, "type": "bullet_group"}], "indent": 0, "level": 2, "text": ["Notes"], "extent": [848, 860], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [2071, 2220], "text": ["When Houdini calls your script, it adds a dictionary variable named ", {"text": ["kwargs"], "type": "code"}, " to the script\u2019s context. This dictionary contains the following keys:"]}, {"body": [{"body": [{"indent": 0, "text": [{"text": ["pane"], "type": "code"}, " "], "role": "td", "attrs": {"width": "20%"}, "extent": [2262, 2272], "container": true, "type": "cell"}, {"indent": 4, "text": [{"text": "", "value": "/hom/hou/PathBasedPaneTab", "fallback_text": "hou.PathBasedPaneTab", "fullpath": "/hom/hou/PathBasedPaneTab", "scheme": "Hom", "type": "link"}, " subclass "], "role": "td", "attrs": {"width": "20%"}, "extent": [2288, 2330], "container": true, "type": "cell"}, {"body": [{"indent": 8, "type": "para", "extent": [2350, 2399], "text": ["The pane in which the tool was invoked."]}, {"body": [{"indent": 8, "blevel": 10, "type": "bullet", "extent": [2399, 2489], "text": ["If the tool was invoked in a Scene Viewer, this will be ", {"text": "", "value": "/hom/hou/SceneViewer", "fallback_text": "hou.SceneViewer", "fullpath": "/hom/hou/SceneViewer", "scheme": "Hom", "type": "link"}, "."]}, {"indent": 8, "blevel": 10, "type": "bullet", "extent": [2489, 2651], "text": ["You must also handle the case where the user invoked the tool from a ", {"text": ["Context"], "type": "em"}, " Viewer (a viewer type that adapts to the current network). In that case"]}, {"indent": 8, "blevel": 10, "type": "bullet", "extent": [2651, 2859], "text": ["If the tool was invoked from the shelf, this is ", {"text": ["None"], "type": "code"}, ". In this case, if you need a viewer your script will have to find one, for example with ", {"text": ["hou.ui.paneTabOfType(hou.paneTabTypes.SceneViewer)"], "type": "code"}, "."]}], "container": true, "type": "bullet_group"}, {"indent": 8, "type": "para", "extent": [2859, 3008], "text": ["See the ", {"text": ["scene_viewer()"], "type": "code"}, " ", {"fragment": "#scene_viewer", "text": ["utility function"], "value": "#scene_viewer", "fullpath": "/hom/tool_script#scene_viewer", "scheme": null, "type": "link"}, " below for a function to get a scene viewer no matter what the value of ", {"text": ["pane"], "type": "code"}, " is."]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 0, "text": [{"text": ["viewport"], "type": "code"}, " "], "role": "td", "extent": [3008, 3021], "container": true, "type": "cell"}, {"indent": 4, "text": [{"text": "", "value": "/hom/hou/GeometryViewport", "fallback_text": "hou.GeometryViewport", "fullpath": "/hom/hou/GeometryViewport", "scheme": "Hom", "type": "link"}, " "], "role": "td", "extent": [3021, 3054], "container": true, "type": "cell"}, {"body": [{"indent": 8, "type": "para", "extent": [3054, 3212], "text": ["The viewport in which the tool was invoked. If the tool was not invoked in a Scene Viewer (or Context Viewer viewing geometry), this will be ", {"text": ["None"], "type": "code"}, "."]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 0, "text": [{"text": ["panename"], "type": "code"}, " "], "role": "td", "extent": [3212, 3225], "container": true, "type": "cell"}, {"indent": 4, "text": [{"text": ["str"], "type": "code"}, " "], "role": "td", "extent": [3225, 3237], "container": true, "type": "cell"}, {"body": [{"indent": 8, "type": "para", "extent": [3237, 3317], "text": ["The name of the pane in which the tool was invoked (see ", {"text": ["pane"], "type": "code"}, " above)."]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 0, "text": [{"text": ["toolname"], "type": "code"}, " "], "role": "td", "extent": [3317, 3330], "container": true, "type": "cell"}, {"indent": 4, "text": [{"text": ["str"], "type": "code"}, " "], "role": "td", "extent": [3330, 3342], "container": true, "type": "cell"}, {"body": [{"indent": 8, "type": "para", "extent": [3342, 3383], "text": ["The internal name of this tool."]}], "role": "td", "type": "cell"}], "divider": true, "type": "row"}, {"body": [{"indent": 0, "text": [{"text": ["shiftclick"], "type": "code"}, " "], "role": "td", "extent": [3398, 3414], "container": true, "type": "cell"}, {"indent": 4, "text": [{"text": ["bool"], "type": "code"}, " "], "role": "td", "extent": [3414, 3427], "container": true, "type": "cell"}, {"body": [{"indent": 8, "type": "para", "extent": [3427, 3542], "text": ["Whether the user was holding ", {"keys": ["Shift"], "text": null, "type": "keys"}, " when they clicked the tool (or selected it from the ", {"keys": ["Tab"], "text": null, "type": "keys"}, " menu)."]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 0, "text": [{"text": ["ctrlclick"], "type": "code"}, " "], "role": "td", "extent": [3542, 3556], "container": true, "type": "cell"}, {"indent": 4, "text": [{"text": ["bool"], "type": "code"}, " "], "role": "td", "extent": [3556, 3569], "container": true, "type": "cell"}, {"body": [{"indent": 8, "type": "para", "extent": [3569, 3683], "text": ["Whether the user was holding ", {"keys": ["Ctrl"], "text": null, "type": "keys"}, " when they clicked the tool (or selected it from the ", {"keys": ["Tab"], "text": null, "type": "keys"}, " menu)."]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 0, "text": [{"text": ["altclick"], "type": "code"}, " "], "role": "td", "extent": [3683, 3696], "container": true, "type": "cell"}, {"indent": 4, "text": [{"text": ["bool"], "type": "code"}, " "], "role": "td", "extent": [3696, 3709], "container": true, "type": "cell"}, {"body": [{"indent": 8, "type": "para", "extent": [3709, 3842], "text": ["Whether the user was holding ", {"keys": ["Alt"], "text": null, "type": "keys"}, " (", {"keys": ["Option"], "text": null, "type": "keys"}, " on Mac) when they clicked the tool (or selected it from the ", {"keys": ["Tab"], "text": null, "type": "keys"}, " menu)."]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 0, "text": [{"text": ["cmdclick"], "type": "code"}, " "], "role": "td", "extent": [3842, 3855], "container": true, "type": "cell"}, {"indent": 4, "text": [{"text": ["bool"], "type": "code"}, " "], "role": "td", "extent": [3855, 3868], "container": true, "type": "cell"}, {"body": [{"indent": 8, "type": "para", "extent": [3868, 3997], "text": [{"text": ["Mac only"], "type": "strong"}, ". Whether the user was holding ", {"keys": ["Command"], "text": null, "type": "keys"}, " when they clicked the tool (or selected it from the ", {"keys": ["Tab"], "text": null, "type": "keys"}, " menu)."]}], "role": "td", "type": "cell"}], "divider": true, "type": "row"}, {"body": [{"indent": 0, "text": [{"text": ["requestnew"], "type": "code"}, " "], "role": "td", "extent": [4011, 4027], "container": true, "type": "cell"}, {"indent": 4, "text": [{"text": ["bool"], "type": "code"}, " "], "role": "td", "extent": [4027, 4040], "container": true, "type": "cell"}, {"body": [{"indent": 8, "type": "para", "extent": [4040, 4262], "text": ["Indicates whether the tool should create a new instance of the node (the usual), or re-use an existing node (for example, the ", {"text": ["Edit SOP"], "fullpath": "/nodes/sop/edit", "scheme": "Node", "type": "link", "value": "/nodes/sop/edit"}, " and ", {"text": ["UV Edit SOP"], "fullpath": "/nodes/sop/uvedit", "scheme": "Node", "type": "link", "value": "/nodes/sop/uvedit"}, " nodes are capable of this)."]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 0, "text": [{"text": ["branch"], "type": "code"}, " "], "role": "td", "extent": [4262, 4273], "container": true, "type": "cell"}, {"indent": 4, "text": [{"text": ["bool"], "type": "code"}, " "], "role": "td", "extent": [4273, 4286], "container": true, "type": "cell"}, {"body": [{"indent": 8, "type": "para", "extent": [4286, 4388], "text": ["Whether to create the new node in a branch instead of appending to the current display node."]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 0, "text": [{"text": ["autoplace"], "type": "code"}, " "], "role": "td", "extent": [4388, 4402], "container": true, "type": "cell"}, {"indent": 4, "text": [{"text": ["bool"], "type": "code"}, " "], "role": "td", "extent": [4402, 4415], "container": true, "type": "cell"}, {"body": [{"indent": 8, "type": "para", "extent": [4415, 4600], "text": ["If this is ", {"text": ["True"], "type": "code"}, ", the tool should place the node in the network without asking the user for a position. (This is separate from checking if ", {"keys": ["Ctrl"], "text": null, "type": "keys"}, "/", {"keys": ["Command"], "text": null, "type": "keys"}, " were pressed.)"]}, {"indent": 8, "type": "para", "extent": [4600, 4777], "text": ["This is set when a tool is invoked in way that has no concept of placement or modifier clicks, for example dragging a node from the Tool Palette in the network editor."]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 0, "text": [{"text": ["bbox"], "type": "code"}, " "], "role": "td", "extent": [4777, 4786], "container": true, "type": "cell"}, {"indent": 4, "text": [{"text": "", "value": "/hom/hou/BoundingBox", "fallback_text": "hou.BoundingBox", "fullpath": "/hom/hou/BoundingBox", "scheme": "Hom", "type": "link"}, " "], "role": "td", "extent": [4786, 4814], "container": true, "type": "cell"}, {"body": [{"indent": 8, "type": "para", "extent": [4814, 4988], "text": [{"text": ["May not be present"], "type": "strong"}, ". If this value is in the dictionary, it contains a bounding box you can use to represent an object, for the purpose of ", {"fragment": "#get_position", "text": ["placing"], "value": "#get_position", "fullpath": "/hom/tool_script#get_position", "scheme": null, "type": "link"}, "."]}, {"indent": 8, "type": "para", "extent": [4988, 5220], "text": ["This value does not come from Houdini but instead is set for a tool by the ", {"text": ["bbox"], "type": "code"}, " attribute in a ", {"text": [".shelf"], "type": "code"}, " file. (Houdini uses this internally to record a ", {"text": ["bbox"], "type": "code"}, " value for the shape tools based on the geometry they create.)"]}], "role": "td", "type": "cell"}], "divider": true, "type": "row"}, {"body": [{"indent": 0, "text": [{"text": ["inputs"], "type": "code"}, " "], "role": "td", "extent": [5234, 5246], "container": true, "type": "cell"}, {"indent": 4, "text": [{"text": ["list"], "type": "code"}, " of ", {"text": ["tuples"], "type": "code"}, " of ", {"text": "", "value": "/hom/hou/Node", "fallback_text": "hou.Node", "fullpath": "/hom/hou/Node", "scheme": "Hom", "type": "link"}, " and ", {"text": ["int"], "type": "code"}, " "], "role": "td", "extent": [5246, 5299], "container": true, "type": "cell"}, {"body": [{"indent": 8, "type": "para", "extent": [5299, 5552], "text": ["A list of nodes and output connector indices that should be wired into the inputs of the new node. This list will be non-empty if the user presses ", {"keys": ["MMB"], "text": null, "type": "keys"}, " or ", {"keys": ["RMB"], "text": null, "type": "keys"}, " on a node output, which lets the user choose a node to wire from that output."]}, {"indent": 8, "type": "para", "extent": [5552, 5724], "text": ["For backwards compatibility, the ", {"text": ["kwargs"], "type": "code"}, " dict also has ", {"text": ["inputnodename"], "type": "code"}, " and ", {"text": ["outputindex"], "type": "code"}, ", which were used previously when only one input node could be specified."]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 0, "text": [{"text": ["inputnodename"], "type": "code"}, " "], "role": "td", "extent": [5724, 5742], "container": true, "type": "cell"}, {"indent": 4, "text": [{"text": ["str"], "type": "code"}, " "], "role": "td", "extent": [5742, 5754], "container": true, "type": "cell"}, {"body": [{"indent": 8, "type": "para", "extent": [5754, 5865], "text": ["The name of a node to wire into the new node\u2019s input, or ", {"text": ["\"\""], "type": "code"}, " (the empty string). See ", {"text": ["inputs"], "type": "code"}, " above."]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 0, "text": [{"text": ["outputindex"], "type": "code"}, " "], "role": "td", "extent": [5865, 5881], "container": true, "type": "cell"}, {"indent": 4, "text": [{"text": ["int"], "type": "code"}, " "], "role": "td", "extent": [5881, 5893], "container": true, "type": "cell"}, {"body": [{"indent": 8, "type": "para", "extent": [5893, 6011], "text": ["The index of a the output on ", {"text": ["inputnodename"], "type": "code"}, " to wire into the new node\u2019s input, or ", {"text": ["-1"], "type": "code"}, ". See ", {"text": ["inputs"], "type": "code"}, " above."]}], "role": "td", "type": "cell"}], "divider": true, "type": "row"}, {"body": [{"indent": 0, "text": [{"text": ["outputs"], "type": "code"}, " "], "role": "td", "extent": [6025, 6038], "container": true, "type": "cell"}, {"indent": 4, "text": [{"text": ["list"], "type": "code"}, " of ", {"text": ["tuples"], "type": "code"}, " of ", {"text": "", "value": "/hom/hou/Node", "fallback_text": "hou.Node", "fullpath": "/hom/hou/Node", "scheme": "Hom", "type": "link"}, " and ", {"text": ["int"], "type": "code"}, " "], "role": "td", "extent": [6038, 6091], "container": true, "type": "cell"}, {"body": [{"indent": 8, "type": "para", "extent": [6091, 6341], "text": ["A list of nodes and input connector indices that should be wired into the output of the new node. This list will be non-empty if the user presses ", {"keys": ["MMB"], "text": null, "type": "keys"}, " or ", {"keys": ["RMB"], "text": null, "type": "keys"}, " on a node input, which lets the user choose a node to wire into that input."]}, {"indent": 8, "type": "para", "extent": [6341, 6514], "text": ["For backwards compatibility, the ", {"text": ["kwargs"], "type": "code"}, " dict also has ", {"text": ["outputnodename"], "type": "code"}, " and ", {"text": ["inputindex"], "type": "code"}, ", which were used previously when only one output node could be specified."]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 0, "text": [{"text": ["outputnodename"], "type": "code"}, " "], "role": "td", "extent": [6514, 6533], "container": true, "type": "cell"}, {"indent": 4, "text": [{"text": ["str"], "type": "code"}, " "], "role": "td", "extent": [6533, 6545], "container": true, "type": "cell"}, {"body": [{"indent": 8, "type": "para", "extent": [6545, 6658], "text": ["The name of a node to wire into the new node\u2019s output, or ", {"text": ["\"\""], "type": "code"}, " (the empty string). See ", {"text": ["outputs"], "type": "code"}, " above."]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}, {"body": [{"indent": 0, "text": [{"text": ["inputindex"], "type": "code"}, " "], "role": "td", "extent": [6658, 6673], "container": true, "type": "cell"}, {"indent": 4, "text": [{"text": ["int"], "type": "code"}, " "], "role": "td", "extent": [6673, 6685], "container": true, "type": "cell"}, {"body": [{"indent": 8, "type": "para", "extent": [6685, 6804], "text": ["The index of a the input on ", {"text": ["outputnodename"], "type": "code"}, " to wire into the new node\u2019s input, or ", {"text": ["-1"], "type": "code"}, ". See ", {"text": ["inputs"], "type": "code"}, " above."]}], "role": "td", "type": "cell"}], "divider": false, "type": "row"}], "type": "table", "thead": [{"body": [{"indent": 0, "text": ["Key "], "role": "th", "extent": [2220, 2227], "container": true, "type": "cell"}, {"indent": 4, "text": ["Type "], "role": "th", "extent": [2227, 2239], "container": true, "type": "cell"}, {"indent": 8, "role": "th", "type": "cell", "extent": [2239, 2262], "text": ["Description "]}], "divider": false, "type": "row"}]}], "indent": 0, "level": 2, "text": ["Arguments"], "extent": [2055, 2071], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [6836, 7178], "text": ["The current API for building tool scripts is very low level (for example, each script is responsible for manually checking the world up, orienting to the construction plane, checking modifier keys, wiring nodes into the correct place, and more). We want to make this much easier though a higher-level HOM API in future versions of Houdini."]}, {"indent": 0, "type": "para", "extent": [7178, 7408], "text": ["For now, we provide the ", {"text": ["stateutils"], "type": "code"}, " module in an attempt to abstract some of the details. You can see usages of the functions in the ", {"fragment": "#howto", "text": ["how to"], "value": "#howto", "fullpath": "/hom/tool_script#howto", "scheme": null, "type": "link"}, " section. The functions in ", {"text": ["stateutils"], "type": "code"}, " are geared toward scripting SOP assets."]}, {"indent": 0, "type": "para", "extent": [7408, 7950], "text": ["\"Factory\" Houdini shelf tools use a variety of internal libraries (", {"text": ["toolutils"], "type": "code"}, ", ", {"text": ["soputils"], "type": "code"}, ", ", {"text": ["doputils"], "type": "code"}, ", and others). These libraries are undocumented, do not provide good examples of Python usage, and are subject to change/deletion without notice. The plan is to replace them with a higher-level HOM API as mentioned above. However, currently it is sometimes necessary to call functions from those libraries. In the \"how to\" section below, the code snippets will sometimes call these functions when the user is not interacting in a viewer."]}], "indent": 0, "level": 2, "text": ["Utility functions"], "extent": [6804, 6836], "container": true, "type": "h", "id": "utils"}, {"body": [{"body": [{"indent": 0, "type": "para", "extent": [8014, 8208], "text": ["There are a few utility functions for getting a reference to the active pane or a ", {"text": "", "value": "/hom/hou/SceneViewer", "fallback_text": "hou.SceneViewer", "fullpath": "/hom/hou/SceneViewer", "scheme": "Hom", "type": "link"}, " instance. These account for edge cases like context viewers that are viewing the scene."]}, {"lang": "python", "indent": 0, "type": "pre", "extent": [8208, 9121], "text": ["\n# In a tool script\nimport stateutils\n\n\n# Get the currently active pane. If kwargs[\"pane\"] is None (like if the script\n# is run from a shelf tool), this will call findSceneViewer() to find a\n# SceneViewer. Otherwise this might be another pane type, such as a\n# hou.NetworkEditor if the tool was selected in the network editor. You should\n# check the type before assuming it's a SceneViewer.\npane = stateutils.activePane(kwargs)\n\n# Get a hou.SceneViewer. If kwargs[\"pane\"] is a SceneViewer, this returns\n# that, otherwise it uses findSceneViewer() to find any SceneViewer it can.\nscene_viewer = stateutils.activeSceneViewer(kwargs['pane'])\n\n# This looks for visible scene viewers first, then falls back to finding a\n# viewer that is not visible and making it the current tab. May raise\n# hou.NotAvailble if there really is no SceneViewer in the desktop.\nscene_viewer = stateutils.findSceneViewer()\n"]}], "indent": 0, "level": 3, "text": ["Get a scene viewer"], "extent": [7971, 8014], "container": true, "type": "h", "id": "scene_viewer"}, {"body": [{"indent": 0, "type": "para", "extent": [9161, 9271], "text": ["A ", {"text": ["generator"], "type": "em"}, " SOP is one which generates data without any input (as opposed to modifying an incoming node)."]}, {"lang": "python", "indent": 0, "type": "pre", "extent": [9271, 9880], "text": ["\n# In a tool script\nimport soptoolutils\nimport stateutils\n\n\npane = stateutils.activePane(kwargs)\nif isinstance(pane, hou.SceneViewer):\n    # This function asks for a position (or auto-places if the user ctrl/cmd-\n    # clicked), then creates a Geometry object and puts your SOP inside (also\n    # handles \"create in context\" setting)\n    stateutils.createGeneratorSop(\n        kwargs, \"$HDA_NAME\", prompt=\"Select where to put the new thing\"\n    )\nelse:\n    # For interactions other than in a viewer, fall back to the low-level\n    # function\n    soptoolutils.genericTool(kwargs, \"$NODE_NAME\")\n"]}], "indent": 0, "level": 3, "text": ["Put down a generator SOP node"], "extent": [9121, 9161], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [9922, 10018], "text": ["A ", {"text": ["filter"], "type": "em"}, " node is one which takes one or more inputs, modifies them, and outputs the result."]}, {"indent": 0, "type": "para", "extent": [10018, 10119], "text": ["The following shows how you could implement a tool script for the traditional ", {"text": ["Copy to Points"], "type": "code"}, " SOP."]}, {"lang": "python", "indent": 0, "type": "pre", "extent": [10119, 11846], "text": ["\n# In a tool script\nimport soptoolutils\nimport stateutils\n\n\npane = stateutils.activePane(kwargs)\nif isinstance(pane, hou.SceneViewer):\n    # First we'll ask for the primitive(s) to copy\n    source = stateutils.Selector(\n        name=\"select_polys\",\n        geometry_types=[hou.geometryType.Primitives],\n        prompt=\"Select primitive(s) to copy, then press Enter\",\n        primitive_types=[hou.primType.Polygon],\n        # Which paramerer to fill with the prim nums\n        group_parm_name=\"sourcegroup\",\n        # Which input on the new node to wire this selection to\n        input_index=0,\n        input_required=True,\n    )\n    # Then, we'll ask for the points to copy onto\n    target = stateutils.Selector(\n        name=\"select_points\",\n        geometry_types=[hou.geometryType.Points],\n        prompt=\"Select points to copy onto, then press Enter\",\n        group_parm_name=\"targetgroup\",\n        # Remember to wire each selection into the correct input :)\n        input_index=1,\n        input_required=True,\n    )\n\n    # This function takes the list of Selector objects and prompts the user for\n    # each selection\n    container, selections = stateutils.runSelectors(\n        pane, [source, target], allow_obj_selection=True\n    )\n\n    # This function takes the container and selections from runSelectors() and\n    # creates the new node, taking into account merges and create-in-context\n    newnode = stateutils.createFilterSop(\n        kwargs, \"$HDA_NAME\", container, selections\n    )\n    # Finally enter the node's state\n    pane.enterCurrentNodeState()\n\nelse:\n    # For interactions other than in a viewer, fall back to the low-level\n    # function\n    soptoolutils.genericTool(kwargs, \"$HDA_NAME\")\n"]}, {"indent": 0, "type": "para", "extent": [11846, 12271], "text": ["Here\u2019s a simpler example where the script prompts the user to select an object (or proceeds if the viewer is already inside an object), and then creates the new node in that object, without any component selection. If the user presses ", {"keys": ["Enter"], "text": null, "type": "keys"}, " without selecting a Geometry object, the tool creates a new object for itself. This might be useful for a node that can add geometry to its input but doesn\u2019t modify a selection."]}, {"lang": "python", "indent": 0, "type": "pre", "extent": [12271, 13935], "text": ["\n# In a tool script\nimport soptoolutils\nimport stateutils\n\n\n_, _, basename, _ = hou.hda.componentsFromFullNodeTypeName(\"$HDA_NAME\")\n\n\npane = stateutils.activePane(kwargs)\nif isinstance(pane, hou.SceneViewer):\n    # Instead of using runSelectors(), which lets the user select components,\n    # we'll just ask for an object if needed\n    container = pane.pwd()\n    if container.childTypeCategory() != hou.sopNodeTypeCategory():\n        # We're not already inside an object, so ask the user where they want\n        # the new SOP\n        objects = pane.selectObjects(\n            prompt='Select objects',\n            quick_select=False,\n            use_existing_selection=True,\n            allow_multisel=False,\n            allowed_types=['geo']\n        )\n        if objects:\n            # If the user selected more than one object, just take the first\n            container = objects[0]\n            # Jump into the object\n            pane.setPwd(container)\n        else:\n            # The user pressed Enter without selecting an object, so create\n            # a new object\n            cname = basename + \"_object1\"\n            container = hou.node(\"/obj\").createNode(\"geo\", node_name=cname)\n\n        # Dive into the container\n        pane.setPwd(container)\n\n    # Create the new node in the selected container (the empty list represents\n    # no component selections)\n    newnode = stateutils.createFilterSop(kwargs, \"$HDA_NAME\", [])\n    # Finally enter the node's state\n    pane.enterCurrentNodeState()\n\nelse:\n    # For interactions other than in a viewer, fall back to the low-level\n    # function\n    soptoolutils.genericTool(kwargs, \"$HDA_NAME\")\n"]}, {"indent": 0, "type": "para", "extent": [13935, 13944], "text": ["Notes:"]}, {"body": [{"indent": 0, "blevel": 2, "type": "bullet", "extent": [13944, 14348], "text": ["If the ", {"text": ["allow_obj_selection"], "type": "code"}, " argument to ", {"text": ["stateutils.runSelectors()"], "type": "code"}, " is ", {"text": ["True"], "type": "code"}, " (the default), and the user starts the tool at the object level, the script will allow the user to select whole objects (rather than components). If the argument is ", {"text": ["False"], "type": "code"}, ", if the user starts at the object level, the script will prompt the user to select an object and then dive inside and request a component selection."]}, {"body": [{"lang": null, "indent": 4, "type": "pre", "extent": [14540, 14659], "text": ["\n    selectors = nodetype.selectors()\n    container, selections = runSelectors(scene_viewer, selectors)\n    "]}], "indent": 0, "text": ["If you want to run the selectors associated with a traditional Houdini node (for example, a node inside your asset), you can get a list of its selectors using ", {"fragment": "#selectors", "text": "", "value": "/hom/hou/NodeType#selectors", "fallback_text": "hou.NodeType.selectors", "fullpath": "/hom/hou/NodeType#selectors", "scheme": "Hom", "type": "link"}, "."], "extent": [14348, 14540], "container": true, "blevel": 2, "type": "bullet"}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [14659, 14771], "text": ["When writing your own custom prompt text, remember to tell the user to press Enter to finish the selection."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [14771, 14974], "text": ["If you try to test the scene_viewer.selectXXX methods in the Python Shell window, it may seem to freeze or not do anything. This is because the prompt only appears when the mouse is over the viewer."]}], "container": true, "type": "bullet_group"}], "indent": 0, "level": 3, "text": ["Put down a filter node"], "extent": [9880, 9922], "container": true, "type": "h", "id": "filter"}, {"body": [{"indent": 0, "type": "para", "extent": [15059, 15169], "text": ["To ask the user for a location, as when you place new geometry using the tools on the ", {"text": ["Create"], "type": "ui"}, " shelf tab."]}, {"indent": 0, "type": "para", "extent": [15169, 15622], "text": ["For tools with a \"placement\" phase (for example, the Sphere tool which lets you place a new sphere in the scene), whether to skip placement and just pick a \"natural\" placement. (For example, for the sphere tool, this places the sphere at the origin. For the Camera tool, this positions the camera to match the current view). The user invokes \"auto-placement\" by ", {"keys": ["Ctrl"], "text": null, "type": "keys"}, "-clicking on Linux/Windows or ", {"keys": ["Command"], "text": null, "type": "keys"}, "-clicking on Mac. You should check both:"]}, {"lang": "python", "indent": 0, "type": "pre", "extent": [15622, 16649], "text": ["\nimport stateutils\n\n\n# The selectPositions() method of the hou.SceneViewer object lets you prompt\n# the user for a certain number of positions (using the min_number_of_positions\n# and number_of_positions keywords), optionally connecting multiple positions\n# (for example when prompting for a path), displaying a bounding box (when\n# prompting to place geometry), etc.\n\nscene_viewer = stateutils.activeSceneViewer(kwargs['pane'])\nif kwargs['ctrlclick'] or kwargs['cmdclick']:\n    position, orientation = \\\n        stateutils.defaultPositionAndOrientation(scene_viewer)\nelse:\n    # The result is a tuple of Vector3 objects.\n    positions = scene_viewer.selectPositions(\n        prompt='Click to specify a position',\n        number_of_positions=1,\n        min_number_of_positions=-1,\n        connect_positions=True,\n        show_coordinates=True,\n        bbox=kwargs.get(\"bbox\", BoundingBox()),\n        position_type=positionType.WorldSpace,\n        icon=None,\n        label=None\n    )\n    position = positions[0]\n"]}, {"indent": 0, "type": "para", "extent": [16649, 16759], "text": ["See the help for ", {"fragment": "#selectPositions", "text": "", "value": "/hom/hou/SceneViewer#selectPositions", "fallback_text": "hou.SceneViewer.selectPositions", "fullpath": "/hom/hou/SceneViewer#selectPositions", "scheme": "Hom", "type": "link"}, ", ", {"text": "", "value": "/hom/hou/BoundingBox", "fallback_text": "hou.BoundingBox", "fullpath": "/hom/hou/BoundingBox", "scheme": "Hom", "type": "link"}, ", and ", {"text": "", "value": "/hom/hou/positionType", "fallback_text": "hou.positionType", "fullpath": "/hom/hou/positionType", "scheme": "Hom", "type": "link"}, "."]}], "indent": 0, "level": 3, "text": ["Prompt the user for a position, multiple positions, or a path"], "extent": [14974, 15059], "container": true, "type": "h", "id": "get_position"}, {"body": [{"lang": "python", "indent": 0, "type": "pre", "extent": [16790, 17034], "text": ["\n# Get a list of all parameters on a node\nall_parms = my_cam.parms()\n\n# Get the current value of a parameter\ncurrent_lookat = my_cam.parm(\"lookat\").get()\n\n# Set the value of a parameter\nmy_cam.parm(\"lookat\").set(\"/obj/torus1\")\n"]}, {"body": [{"body": [{"indent": 4, "type": "para", "extent": [17040, 17260], "text": ["The argument to the ", {"text": ["Node.parm()"], "type": "code"}, " method is the ", {"text": ["internal"], "type": "em"}, " name of the parameter. To find out the internal name of a parameter, hover over its label in the parameter editor. The internal name appears in a tooltip."]}], "indent": 0, "role": "item", "extent": [17034, 17040], "container": true, "type": "tip"}], "container": true, "role": "item_group", "type": "tip_group"}], "indent": 0, "level": 3, "text": ["Modify node parameters"], "extent": [16759, 16790], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [17318, 17638], "text": ["You might want to make a tool that works inside two or more different network types. For example, the ", {"text": "", "fullpath": "/hom/COMMON/delete", "scheme": "Icon", "type": "link", "value": "COMMON/delete"}, " Delete action on the ", {"text": ["Modify"], "type": "ui"}, " shelf tab works at both the object level, where it deletes the selected object, and at the geometry level, where it creates a ", {"text": ["Blast surface node"], "fullpath": "/nodes/sop/blast", "scheme": "Node", "type": "link", "value": "/nodes/sop/blast"}, "."]}, {"indent": 0, "type": "para", "extent": [17638, 17764], "text": ["There are a few ways you could write this part of your script. One is to follow the code used by the Delete action\u2019s script:"]}, {"lang": "python", "indent": 0, "type": "pre", "extent": [17764, 18455], "text": ["\n# In a tool script\nimport stateutils\n\n\n# Find out current context. Returns the active pane when the tool/action was\n# called. If there is not an active pane when the tool/action is called, this\n# returns None.\nscene_viewer = stateutils.active_scene_viewer(kwargs['pane'])\n\n# If the active pane is not a scene viewer, raise an error\nif not scene_viewer\n   raise hou.Error(\"The tool was not invoked in the scene viewer.\")\n\n# Get the network context of the viewer.\nchild_type = active_pane.pwd().childTypeCategory()\n\nif child_type == hou.objNodeTypeCategory():\n    ...\nelif child_type == hou.sopNodeTypeCategory():\n    ...\nelif child_type == hou.dopNodeTypeCategory():\n    ...\n"]}], "indent": 0, "level": 3, "text": ["Detect what network context the tool is called in"], "extent": [17260, 17318], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [18497, 18530], "text": ["To get the current viewport\u2026"]}, {"lang": "python", "indent": 0, "type": "pre", "extent": [18530, 18702], "text": ["\nimport stateutils\n\n# Get the scene viewer\nscene_viewer = stateutils.find_scene_viewer()\n\n# Get the current viewport\nviewport =  scene_viewer.curViewport()\n"]}, {"indent": 0, "type": "para", "extent": [18702, 18961], "text": ["Calling the ", {"text": ["settings()"], "type": "code"}, " method on the ", {"text": ["GeometryViewport"], "fullpath": "/hom/hou/GeometryViewport", "scheme": "Hom", "type": "link", "value": "/hom/hou/GeometryViewport"}, " object returns a ", {"text": ["GeometryViewportSettings"], "fullpath": "/hom/hou/GeometryViewportSettings", "scheme": "Hom", "type": "link", "value": "/hom/hou/GeometryViewportSettings"}, " object. This object has a ton of methods for getting and setting information about the viewport."]}, {"lang": "python", "indent": 0, "type": "pre", "extent": [18961, 19046], "text": ["\n# Get the viewport's settings object\nsettings = viewport.settings()\n"]}, {"indent": 0, "type": "para", "extent": [19046, 19227], "text": ["Among the most useful methods on the settings object are ", {"text": ["viewTransform()"], "type": "code"}, " and ", {"text": ["setViewTransform()"], "type": "code"}, ", which get and set the viewport\u2019s transformation matrix respectively. You can "]}, {"indent": 0, "type": "para", "extent": [19227, 19281], "text": ["To set the viewport to look through a camera, use\u2026"]}, {"lang": "python", "indent": 0, "type": "pre", "extent": [19281, 19330], "text": ["\nviewport.setCamera(camera_node)\n"]}, {"indent": 0, "type": "para", "extent": [19330, 19403], "text": ["To get the camera node that a viewport is currently looking through\u2026"]}, {"lang": "python", "indent": 0, "type": "pre", "extent": [19403, 19496], "text": ["\n# Returns None if not looking through a camera\nviewport.settings().camera()\n"]}, {"indent": 0, "type": "para", "extent": [19496, 19682], "text": ["There\u2019s a special method on viewports to copy their view to a camera or light, so you can copy the ctrl-click behavior of the standard tools on the ", {"text": ["Lights and Cameras"], "type": "ui"}, " shelf tab\u2026"]}, {"lang": "python", "indent": 0, "type": "pre", "extent": [19682, 19746], "text": ["\nviewport.saveViewToCamera(cam_or_light_object)\n"]}], "indent": 0, "level": 3, "text": ["Manipulate the current viewport"], "extent": [18455, 18497], "container": true, "type": "h", "id": null}], "indent": 0, "level": 2, "text": ["How to"], "extent": [7950, 7971], "container": true, "type": "h", "id": "howto"}], "summary": ["How to write Python scripts for shelf/asset tools."], "type": "root", "attrs": {}, "title": ["Tool scripts"]}