{"body": [{"indent": 0, "text": ["HOM introduction"], "type": "title", "extent": [0, 21], "level": 0}, {"body": [{"indent": 0, "type": "para", "extent": [37, 249], "text": ["Here\u2019s a quick example of how to use HOM to accomplish a simple\ntask in Houdini.  Don\u2019t worry if you don\u2019t understand the details\nof this example \u2013 it will give you a flavor of what scripting\nHoudini is like."]}, {"indent": 0, "type": "para", "extent": [249, 328], "text": ["Choose ", {"text": ["Windows \u25b8 Python Shell"], "type": "ui"}, " to open an interactive\nPython Shell window."]}, {"lang": "pycon", "indent": 0, "type": "pre", "extent": [328, 723], "text": ["\n\n# Print out a tree of all the nodes in the scene:\n>>> def print_tree(node, indent=0):\n...     for child in node.children():\n...         print \" \" * indent + child.name()\n...         print_tree(child, indent + 3)\n... # Press Enter to finish the definition\n\n>>> print_tree(hou.node('/'))\nobj\n   cam1\n      file1\n      properties\n         standard\nout\npart\nch\nshop\nimg\n   img1\nvex\n"]}], "indent": 0, "level": 2, "text": ["Overview"], "extent": [21, 37], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [746, 1008], "text": ["When you open Houdini\u2019s Python shell, you\u2019ll notice it greets you with\nthe ", {"text": [">>>"], "type": "code"}, " prompt and waits for you to enter Python expressions or\nstatements.  Even if you don\u2019t plan on writing large Python scripts, the\nPython shell is invaluable as a handy calculator:"]}, {"lang": "pycon", "indent": 0, "type": "pre", "extent": [1008, 1090], "text": ["\n>>> 2 + 2\n4\n>>> 0.03 * 25.1\n0.753\n>>> min(hou.frame(), 7) * 3\n3.0\n"]}, {"indent": 0, "type": "para", "extent": [1090, 1495], "text": ["What is hou.frame(), you might ask?  Houdini\u2019s Python API is implemented in\na module named ", {"text": ["hou"], "type": "code"}, ", short for Houdini.  Just like ", {"text": ["os.getcwd"], "type": "code"}, " is a function\nin the ", {"text": ["os"], "type": "code"}, " module, ", {"text": ["hou.frame"], "type": "code"}, " is a function in the ", {"text": ["hou"], "type": "code"}, " module, and it\nreturns the current frame number.  Note that you don\u2019t need to write ", {"text": ["import\nhou"], "type": "code"}, " to use the hou module, since Houdini automatically imports the hou module\nwhen it starts up."]}, {"indent": 0, "type": "para", "extent": [1495, 1628], "text": ["Press Ctrl+D to close a floating Python shell window.  See the main menu\nfor the shortcut to open the floating Python shell window."]}, {"indent": 0, "type": "para", "extent": [1628, 1707], "text": ["Python shells can be inside panes if you don\u2019t want to use a floating\nwindow."]}, {"indent": 0, "type": "para", "extent": [1707, 1893], "text": ["In the Python shell, ", {"keys": ["Home"], "text": null, "type": "keys"}, " and ", {"keys": ["Ctrl", "A"], "text": null, "type": "keys"}, " will move to the beginning of the\nline, ", {"keys": ["End"], "text": null, "type": "keys"}, " and ", {"keys": ["Ctrl", "E"], "text": null, "type": "keys"}, " will move to the end, and up and down will navigate\nthrough the history."]}, {"indent": 0, "type": "para", "extent": [1893, 2070], "text": ["You can\u2019t use ", {"keys": ["Ctrl", "C"], "text": null, "type": "keys"}, " to copy from the Python shell, since Ctrl+C will\nsend a KeyboardInterrupt exception.  To copy text from a Python shell,\nright-click and select Copy."]}], "indent": 0, "level": 2, "text": ["Getting Started"], "extent": [723, 746], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [2094, 2413], "text": ["Use the ", {"text": "", "value": "/hom/hou/hipFile", "fallback_text": "hou.hipFile", "fullpath": "/hom/hou/hipFile", "scheme": "Hom", "type": "link"}, " submodule to save/load the current session to/from\nhip files.  Note that ", {"fragment": "#load", "text": "", "value": "/hom/hou/hipFile#load", "fallback_text": "hou.hipFile.load", "fullpath": "/hom/hou/hipFile#load", "scheme": "Hom", "type": "link"}, " will throw a ", {"text": "", "value": "/hom/hou/LoadWarning", "fallback_text": "hou.LoadWarning", "fullpath": "/hom/hou/LoadWarning", "scheme": "Hom", "type": "link"}, "\nexception if there were warnings, even though the file was loaded successfully.\nThe following code will print out warnings and continue the rest of the\nscript."]}, {"lang": "python", "indent": 0, "type": "pre", "extent": [2413, 2571], "text": ["\n# Print out load warnings, but continue on a successful load.\ntry:\n    hou.hipFile.load(\"myfile.hip\")\nexcept hou.LoadWarning, e:\n    print e\n"]}], "indent": 0, "level": 2, "text": ["Loading Hip Files"], "extent": [2070, 2094], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [2594, 2760], "text": ["Because Houdini is designed around nodes (e.g. SOPs, DOPs, Object nodes, etc.),\nyou're likely to manipulate them in scripts.  Here\u2019s a brief primer to get\nstarted."]}, {"indent": 0, "type": "para", "extent": [2760, 2891], "text": ["The ", {"text": ["hou.node"], "fullpath": "/hom/hou/node_", "scheme": "Hom", "type": "link", "value": "/hom/hou/node_"}, " function takes a path to a node and returns a ", {"text": "", "value": "/hom/hou/Node", "fallback_text": "hou.Node", "fullpath": "/hom/hou/Node", "scheme": "Hom", "type": "link"}, "\nobject, or None if the path is invalid."]}, {"lang": "pycon", "indent": 0, "type": "pre", "extent": [2891, 5725], "text": ["\n# Empty out the current session.\n>>> hou.hipFile.clear()\n\n>>> hou.node('/obj')\n<hou.Node at /obj>\n>>> # hou.node returned a hou.Node object corresponding to the /obj node\n\n>>> n = hou.node('/asdfasdf')\n>>> # The node path was invalid, so n will be the None object.\n>>> print n\nNone\n\n>>> g = hou.node('/obj').createNode('geo')\n>>> g\n<hou.ObjNode of type geo at /obj/geo1>\n>>> # g is hou.Node object corresponding to the newly created /obj/geo1 node.\n>>> # Note that g is actually a hou.ObjNode instance, which is a subclass of\n>>> # hou.Node.\n\n>>> # The parm method on hou.Node objects returns a hou.Parm object (or None\n>>> # if the parameter name is invalid).\n>>> tx = g.parm('tx')\n>>> tx\n<hou.Parm tx in /obj/geo1>\n\n>>> # Evaluate the parameter and change its value.\n>>> tx.eval()\n0.0\n>>> tx.set(3.5)\n>>> tx.eval()\n3.5\n\n>>> hou.node('/obj/geo1').parm('tx').eval()\n3.5\n>>> # hou.parm is a shortcut to access a parm directly.\n>>> hou.parm('/obj/geo1/tx').eval()\n3.5\n>>> # hou.evalParm is a shortcut to evaluate a parameter.\n>>> hou.evalParm('/obj/geo1/tx')\n3.5\n>>> # hou.ch is exactly the same as hou.evalParm.\n>>> hou.ch('/obj/geo1/tx')\n3.5\n\n>>> # hou.Parm.name returns the name of the parameter, and hou.Node.parms\n>>> # Returns a tuple of all the Node's parameters.\n>>> [p.name() for p in g.parms()]\n['stdswitcher1', 'stdswitcher2', 'stdswitcher3', 'stdswitcher4', 'keeppos',\n'pre_xform', 'xOrd', 'rOrd', 'tx', 'ty', 'tz', 'rx', 'ry', 'rz', 'sx', 'sy',\n'sz', 'px', 'py', 'pz', 'scale', 'lookatpath', 'lookup', 'pathobjpath',\n'roll', 'pos', 'uparmtype', 'pathorient', 'upx', 'upy', 'upz', 'bank',\n'shop_materialpath', 'shop_materialopts', 'tdisplay', 'display',\n'use_dcolor', 'dcolorr', 'dcolorg', 'dcolorb', 'picking', 'pickscript',\n'caching', 'vport_shadeopen', 'vport_displayassubdiv', 'vm_phantom',\n'vm_renderable', 'folder01', 'folder02', 'folder03', 'folder04',\n'categories', 'reflectmask', 'lightmask', 'geo_velocityblur',\n'vm_shadingquality', 'vm_rayshadingquality', 'vm_rmbackface',\n'shop_geometrypath', 'vm_rendersubd', 'vm_renderpoints', 'vm_metavolume',\n'vm_coving', 'vm_computeN']\n\n>>> # hou.Parm tuples correspond to parameter groupings:\n>>> t = g.parmTuple('t')\n>>> t\n<hou.ParmTuple t in /obj/geo1>\n>>> tuple(t)\n(<hou.Parm tx in /obj/geo1>, <hou.Parm ty in /obj/geo1>, <hou.Parm tz in /obj/geo1>)\n>>> t.eval()\n(3.5, 0.0, 0.0)\n>>> t.set((1.0, 2.0, 3.0))\n>>> t.eval()\n(1.0, 2.0, 3.0)\n\n>>> # Build a simple sop network.\n>>> hou.hipFile.clear()\n>>> geo = hou.node('/obj').createNode('geo')\n>>> box = geo.createNode('box')\n>>> subd = geo.createNode('subdivide')\n>>> subd.parm('iterations').set(3)\n>>> subd.setFirstInput(box)\n>>> subd.moveToGoodPosition() # Move the node tiles to avoid overlaps.\n>>> subd.setDisplayFlag(True)\n>>> subd.setRenderFlag(True)\n>>> subd.setCurrent(True, clear_all_selected=True)\n"]}], "indent": 0, "level": 2, "text": ["Accessing Nodes"], "extent": [2571, 2594], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [5779, 6339], "text": ["When you hear the term \"animated parameter\", you typically think of keyframed\nvalues and bezier curves and the animation graph editor.  Recall from earlier,\nthough, that parameters with expressions are also considered animated\nparameters.  All animated parameters have at least one keyframe, and each\nkeyframe has an expression.  Typical parameters with expressions simply have\none keyframe whose expression is something like ", {"text": ["sin($F)"], "type": "code"}, " or ", {"text": ["cos(time())"], "type": "code"}, ",\nwhile typical animation curves have multiple keyframes whose expressions are\nsomething like ", {"text": ["bezier()"], "type": "code"}, "."]}, {"indent": 0, "type": "para", "extent": [6339, 6881], "text": ["So how does a function like ", {"text": ["bezier()"], "type": "code"}, " evaluate to different values at\ndifferent times?  Clearly there are no parameters passed to bezier that\nvary from time to time, and there are no keyframe or slope values passed\nin.  The answer is that keyframes store more than just an expression.\nA keyframe stores those values, slopes, and accelerations, and certain\nfunctions, like bezier, access those values for the current keyframe and\nthe next one.  For keyframes with expressions like ", {"text": ["sin($F)"], "type": "code"}, ", those\nextra values are not set and are not used."]}, {"indent": 0, "type": "para", "extent": [6881, 7428], "text": ["Each keyframe has an associated time.  Using that time and the number of\nframes per second, you can derive the keyframe\u2019s frame.  You can think of\nthe expression as being active ", {"text": ["between"], "type": "em"}, " keyframes: Houdini evaluates the\nexpression between its keyframe and the ", {"text": ["next"], "type": "em"}, " keyframe.  If there is no\nnext keyframe, most animation functions (e.g. ", {"text": ["bezier"], "fullpath": "/hom/hou/bezier", "scheme": "Hom", "type": "link", "value": "/hom/hou/bezier"}, ",\n", {"text": ["cubic"], "fullpath": "/hom/hou/cubic", "scheme": "Hom", "type": "link", "value": "/hom/hou/cubic"}, ", etc.) simply evaluate to their keyframe\u2019s value.  For\nthe times before the first keyframe, the parameter evaluates to the value\nat the first keyframe\u2019s time."]}, {"indent": 0, "type": "para", "extent": [7428, 7488], "text": [{"fragment": "#keyframes", "text": "", "value": "/hom/hou/Parm#keyframes", "fallback_text": "hou.Parm.keyframes", "fullpath": "/hom/hou/Parm#keyframes", "scheme": "Hom", "type": "link"}, "\nvalues, slopes, and accelerations"]}, {"body": [{"indent": 0, "blevel": 2, "type": "bullet", "extent": [7488, 7717], "text": ["If you set the in value and the (out) value is not set, it will be\n  set to the same value.  Setting the in value breaks the tie between\n  the values.  If neither of the in or (out) values are set, they\n  are considered tied."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [7717, 7832], "text": ["for example, to set a keyframe with the current value and slope, do not\n  set the value or slope in the keyframe"]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [7832, 7917], "text": ["or, to automatically determine the slopes, set a keyframe with the slope not\n  set"]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [7917, 7941], "text": ["times and expressions"]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [7941, 7961], "text": ["in and out/values"]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [7961, 7975], "text": ["tied values"]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [7975, 7986], "text": ["asCode()"]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [7986, 8040], "text": ["same syntax between Hscript expressions and Python"]}], "container": true, "type": "bullet_group"}], "indent": 0, "level": 2, "text": ["Working with Animated Parameters and Keyframes"], "extent": [5725, 5779], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"indent": 0, "blevel": 2, "type": "bullet", "extent": [8087, 8128], "text": ["worldTransform(), setWorldTransform()"]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [8128, 8150], "text": ["matrices, exploding"]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [8150, 8215], "text": ["column vectors for transforms (p ", {"text": [" T1 "], "type": "strong"}, " T2), not (T2 ", {"text": [" T1 "], "type": "strong"}, " p)"]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [8215, 8256], "text": ["see the object_xform cookbook example"]}], "container": true, "type": "bullet_group"}], "indent": 0, "level": 2, "text": ["Working with Objects and Transformations"], "extent": [8040, 8087], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"indent": 0, "blevel": 2, "type": "bullet", "extent": [8291, 8362], "text": ["For the shelf/tab menu: in the details section of the popup window."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [8362, 8399], "text": ["For HDA callbacks: in the console."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [8399, 8440], "text": ["For ", {"text": ["123.py"], "type": "code"}, "/", {"text": ["456.py"], "type": "code"}, ": in the console."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [8440, 8475], "text": ["For parameters: ", {"keys": ["MMB"], "text": null, "type": "keys"}, " on node."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [8475, 8519], "text": ["For Python-based nodes: ", {"keys": ["MMB"], "text": null, "type": "keys"}, " on node."]}], "container": true, "type": "bullet_group"}], "indent": 0, "level": 2, "text": ["Where to find error messages"], "extent": [8256, 8291], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [8560, 8796], "text": ["When Python code generates an unhandled exception, it will display a traceback\nof the call stack where the exception was raised.  By looking at the last\nentry in the traceback, you can find the line of code that raised the\nexception."]}, {"indent": 0, "type": "para", "extent": [8796, 8921], "text": ["For example, if there was spelling error in the implementation of\n", {"text": ["fixFilePrefixes"], "type": "code"}, ", you might see the following traceback."]}, {"lang": "pycon", "indent": 0, "type": "pre", "extent": [8921, 9185], "text": ["\n>>> hou.session.fixFilePrefix(hou.node('/'), '/home/luke/project', '$HIP')\nTraceback (most recent call last):\n  File \"<console>\", line 1, in <module>\n  File \"hou.session\", line 12, in fixFilePrefix\nNameError: global name 'to_prefix' is not defined\n"]}, {"indent": 0, "type": "para", "extent": [9185, 9554], "text": ["The last line of the traceback displays the string representation of the\nexception.  The most common exceptions the hou module is likely to raise\nare ", {"text": "", "value": "/hom/hou/OperationFailed", "fallback_text": "hou.OperationFailed", "fullpath": "/hom/hou/OperationFailed", "scheme": "Hom", "type": "link"}, ", ", {"text": "", "value": "/hom/hou/PermissionError", "fallback_text": "hou.PermissionError", "fullpath": "/hom/hou/PermissionError", "scheme": "Hom", "type": "link"}, ",\n", {"text": "", "value": "/hom/hou/LoadWarning", "fallback_text": "hou.LoadWarning", "fullpath": "/hom/hou/LoadWarning", "scheme": "Hom", "type": "link"}, ", and ", {"text": "", "value": "/hom/hou/ObjectWasDeleted", "fallback_text": "hou.ObjectWasDeleted", "fullpath": "/hom/hou/ObjectWasDeleted", "scheme": "Hom", "type": "link"}, ".  A list of all exception\ntypes defined in the hou module can be found in the\n", {"text": ["reference documentation"], "fullpath": "/hom/hou", "scheme": null, "type": "link", "value": "hou"}, "."]}, {"body": [{"body": [{"indent": 4, "type": "para", "extent": [9559, 9774], "text": ["The Python source editor, multi-line expression editor, shelf script\n    editor, and HDA script editors show the line number in the bottom-right\n    corner, helping to locate the line that raised an exception."]}], "indent": 0, "role": "item", "extent": [9554, 9559], "container": true, "type": "tip"}], "container": true, "role": "item_group", "type": "tip_group"}], "indent": 0, "level": 2, "text": ["Interpreting Python error messages"], "extent": [8519, 8560], "container": true, "type": "h", "id": null}, {"body": [{"body": [{"indent": 0, "blevel": 2, "type": "bullet", "extent": [9785, 9949], "text": ["Drag a node from the network editor into the Python shell to paste a\n  hou.node expression.  You may find this easier if the Python shell is\n  inside a pane."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [9949, 10087], "text": ["Use variables to store hou.Node, hou.Parm, and hou.ParmTuple objects\n  instead of calling hou.node and hou.parm over and over again."]}, {"indent": 0, "blevel": 2, "type": "bullet", "extent": [10087, 10224], "text": ["Use the output from ", {"fragment": "#asCode", "text": "", "value": "/hom/hou/Node#asCode", "fallback_text": "hou.Node.asCode", "fullpath": "/hom/hou/Node#asCode", "scheme": "Hom", "type": "link"}, " to help learn the parts of\n  the HOM API that create nodes and set parameters and keyframes."]}], "container": true, "type": "bullet_group"}], "indent": 0, "level": 2, "text": ["Tips"], "extent": [9774, 9785], "container": true, "type": "h", "id": null}], "type": "root", "attrs": {}, "title": ["HOM introduction"]}