{"body": [{"indent": 0, "text": [{"text": ["HOM cookbook"], "type": "supertitle"}, " Wrapper library"], "type": "title", "extent": [0, 36], "level": 0}, {"body": [{"indent": 0, "type": "para", "extent": [52, 241], "text": ["The code in this example defines a simple class that wraps functionality in ", {"text": ["hou"], "type": "code"}, " to make it easier to build compositing networks in Houdini by calling methods on the class. For example:"]}, {"lang": "pycon", "indent": 0, "type": "pre", "extent": [241, 838], "text": ["\n>>> import comp\n\n# Load in $HFS/houdini/pic/default.pic and convert it to a jpeg, writing the\n# output to the current directory.\n>>> comp.readFile(\"default.pic\").writeFile(\"default.jpg\")\n\n# Load in a sequence of images (from $HFS/houdini/pic), brighten them,\n# and convert them to jpegs.\n>>> comp.readFile(\"butterfly$F.pic\").bright(1.8).writeFile(\"butterfly$F.jpg\")\n\n# Load in default.pic, brighten it, composite it over a gray background,\n# and write it to out.pic.\n>>> comp.readFile(\"default.pic\").bright(1.2).over(\n...     comp.constant(0.3, 0.3, 0.3)).writeFile(\"out.pic\")\n...\n"]}, {"indent": 0, "type": "para", "extent": [838, 976], "text": ["As you call the methods on the object returned by ", {"text": ["comp.readFile"], "type": "code"}, ", they COP nodes, set parameters on them, and wire the nodes together."]}, {"body": [{"body": [{"indent": 8, "type": "para", "extent": [981, 1128], "text": ["With some simple extensions to this example, you could create a Python equivalent of Houdini\u2019s ", {"text": ["icomposite"], "fullpath": "/ref/util/icomposite", "scheme": null, "type": "link", "value": "/ref/util/icomposite"}, " program."]}], "indent": 0, "role": "item", "extent": [976, 981], "container": true, "type": "tip"}], "container": true, "role": "item_group", "type": "tip_group"}], "indent": 0, "level": 2, "text": ["Overview"], "extent": [36, 52], "container": true, "type": "h", "id": null}, {"body": [{"indent": 0, "type": "para", "extent": [1149, 1298], "text": ["You can save the source code below to under ", {"text": ["$HOUDINIPATH/pythonX.Xlibs"], "type": "code"}, ". See ", {"fragment": "#disk", "text": ["where to put Python code"], "value": "/hom/locations#disk", "fullpath": "/hom/locations#disk", "scheme": null, "type": "link"}, " for more information."]}, {"lang": "python", "indent": 0, "type": "pre", "extent": [1298, 5050], "text": ["\nimport hou\n\n\"\"\"\nThis module lets you create and evaluate a compositing network simply\nby writing an expression describing the compositing operations to perform.\nWith some simple extensions to this example, you can create a Pythonic\nequivalent of Houdini's icomposite program.\n\nFor example, you can write:\n\n    import comp\n    comp.readFile(\"default.pic\").bright(1.2).over(comp.constant(0.3, 0.3, 0.3)\n        ).writeFile(\"out.pic\")\n\nand Houdini will build a composite network that loads the default.pic image,\nbrightens it, composites it over a constant, and writes out the result to\nout.pic.\n\nNote that this module supports compositing over a sequence of images: simply\nuse a time-dependent expression (like $F) in the input and output image names.\n\nIf you use this module from a graphical Houdini session, you can inspect\nthe compositing networks it creates.\n\"\"\"\n\ndef test():\n    \"\"\"This function creates a simple test case that evaluates the following:\n       comp.readFile(\"default.pic\").bright(1.2).over(\n           comp.constant(0.3, 0.3, 0.3)).writeFile(\"out.pic\")\n    \"\"\"\n    readFile(\"default.pic\").bright(1.2).over(constant(0.3, 0.3, 0.3)\n        ).writeFile(\"out.pic\")\n\nclass _Image:\n    \"\"\"This image class wraps a COP node and exposes image operations via\n       methods that simply create COP nodes and return a new image wrapping\n       that node.\n    \"\"\"\n    def __init__(self, node):\n        # The node parameter is a COP node.  The user of this module will\n        # create images with the readFile and constant methods, and construct\n        # _Image objects directly.\n        self.node = node\n\n    def __createNode(self, type):\n        # Create and return a COP node of the specified type in the current\n        # network.\n        return self.node.parent().createNode(type)\n\n    def bright(self, amount):\n        \"\"\"Brighten the image, returning a new image.\"\"\"\n        n = self.__createNode(\"bright\")\n        n.setFirstInput(self.node)\n        n.parm(\"bright\").set(amount)\n        return _Image(n)\n\n    def over(self, image):\n        \"\"\"Composite this image over the specified one, returning a new\n           image.\"\"\"\n        n = self.__createNode(\"over\")\n        n.setFirstInput(self.node)\n        n.setInput(1, image.node)\n        return _Image(n)\n\n    def writeFile(self, file_name):\n        \"\"\"Write this image to a file or file sequence.\"\"\"\n        n = self.__createNode(\"rop_comp\")\n        n.setFirstInput(self.node)\n        n.parm(\"copoutput\").set(file_name)\n        self.node.parent().layoutChildren()\n\n        # If we're called from a standard Python shell or hython, actually\n        # write out the file.\n        if hou.applicationName() == 'hbatch':\n            n.render()\n\ndef __network():\n    # This internal function just returns the COP network.  For this example,\n    # it simply hard-codes a particular network.\n    return hou.node(\"/img/comp1\") or hou.node(\"/img\").createNode(\"img\", \"comp1\")\n\n_lastResolution = None\n\ndef readFile(file_name):\n    \"\"\"Return an image object corresponding to a file or file sequence.\"\"\"\n    n = __network().createNode(\"file\")\n    n.parm(\"filename1\").set(file_name)\n\n    # Remember the image resolution.  If we later create a constant color,\n    # we'll use this resolution.\n    global _lastResolution\n    _lastResolution = (n.xRes(), n.yRes())\n\n    return _Image(n)\n\ndef constant(r, g, b, a=1.0):\n    \"\"\"Return an image that's a constant color.  The size of the image will\n       be the same as the size of the last file read in.\"\"\"\n    n = __network().createNode(\"color\")\n    n.parmTuple(\"color\").set((r, g, b, a))\n\n    if _lastResolution is not None:\n        n.parm(\"overridesize\").set(True)\n        n.parmTuple(\"size\").set(_lastResolution)\n    return _Image(n)\n"]}], "indent": 0, "level": 2, "text": ["Implementation"], "extent": [1128, 1149], "container": true, "type": "h", "id": null}], "type": "root", "attrs": {}, "title": [{"text": ["HOM cookbook"], "type": "supertitle"}, " Wrapper library"]}